<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ru_RU"><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="https://konstantinklepikov.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://konstantinklepikov.github.io/" rel="alternate" type="text/html" hreflang="ru_RU" /><updated>2020-04-01T19:49:27+02:00</updated><id>https://konstantinklepikov.github.io/feed.xml</id><title type="html">My deep learning</title><subtitle>Блог про нейронные сети и машинное обучение</subtitle><author><name>Klepikov Konstantin</name></author><entry><title type="html">Аргументы функций в Python 3.x. Шпаргалка</title><link href="https://konstantinklepikov.github.io/2020/03/31/functions-arguments-in-pythone.html" rel="alternate" type="text/html" title="Аргументы функций в Python 3.x. Шпаргалка" /><published>2020-03-31T00:00:00+02:00</published><updated>2020-03-31T00:00:00+02:00</updated><id>https://konstantinklepikov.github.io/2020/03/31/functions-arguments-in-pythone</id><content type="html" xml:base="https://konstantinklepikov.github.io/2020/03/31/functions-arguments-in-pythone.html">&lt;p&gt;Статью я написал потому, что постоянно забываю как обращаться к аргументам функций в разных сложных случаях. Надоело гуглить — сделал сеье шпаргалк. Для упрощения ситуации речь пойдет про python 3.x.&lt;/p&gt;

&lt;h2 id=&quot;основные-правила&quot;&gt;Основные правила&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;аргументы передаются через присваивание объектов именам локальных переменных функций&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;при передаче объекты никогда не копируются автоматически&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;присваивание аргументов внутри функции не затрагивает вызывающий код&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;при выполнении функции аргументы функции становятся ее локальными переменными в области видимости функции&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;имена аргументов функции и имена переменных в области видимости функции не совмещаются&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;модификация изменяемого объекта внутри функции может затронуть вызывающий код&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;В примере аргументы присвоен объект, на который указывает переменная из другого контекста. Внутри функции произошло присваивание локальной переменной нового объекта, что не затронуло вызывающий код:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В следующем примере видно, как изменение на месте изменяемого объекта внутри функции приводит к последствиям определенного рода.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'that'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'this'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'this'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'this'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'that'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'this'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'that'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Оператор return поддерживает возврат множественных значений, упаковывая их в коллекцию. Естественно, это можно распаковать в вызывающем коде. Например, так:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;режимы-сопоставления-аргументов&quot;&gt;Режимы сопоставления аргументов&lt;/h2&gt;

&lt;p&gt;При объявлении функции:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;обязательные аргументы будут сопоставляться слева направо с любыми переданными позиционными аргументами при вызове функции &lt;em&gt;def func{имя)&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;стандартные значения, которые будут присвоены аргументу, если в вызове функции аргумент не передавался &lt;em&gt;def func{имя=значение)&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;def func(*имя)&lt;/em&gt; — собирает произвольное количество оставшихся позиционных аргументов в кортеж&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;def func{**имя)&lt;/em&gt; — собирает произвольное количество оставшихся ключевых аргументов в словарь&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;def func(*остальные, имя)&lt;/em&gt; или &lt;em&gt;def func(*, имя=значение)&lt;/em&gt; — аргументы, которые должны быть переданы только по ключевому слову&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;При вызове функции:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;позиционные аргументы сопоставляются слева направо &lt;em&gt;func{значение)&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ключевые сопоставляются по имени аргумента &lt;em&gt;func{имя=значение)&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;func(*итерируемый_объект)&lt;/em&gt; — передает все объекты в итерируемом объекте как отдельные позиционные аргументы&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;func{**словарь)&lt;/em&gt; — передает все объекты в итерируемом объекте как отдельные ключевые аргументы&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;При объявлении функции аргументы должны указываться в следующем порядке:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;любые позиционные аргументы &lt;em&gt;имя&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;любые стандартные аргументы &lt;em&gt;имя=значение&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;форма &lt;em&gt;*имя&lt;/em&gt; или &lt;em&gt;*&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;аргументы, которые должны передаваться только по ключевым словам &lt;em&gt;имя&lt;/em&gt; или &lt;em&gt;имя=значение&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;форма &lt;em&gt;**имя&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;При вызофе функции аргументы должны указываться в следующем порядке:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;любые позиционные аргументы &lt;em&gt;значение&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;комбинация любых ключевых аргументов &lt;em&gt;имя=значение&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;*итерируемый_объект&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;**словарь&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;При несоблюдении указанного порядка выводится синтаксическая ошибка. При этом сопоставляться аргументы будут в следующем порядке:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Присваивание неключевых аргументов по позиции слева направо (порядок следования имеет значение, так как сопоставление осуществляется по позиции)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Присваивание ключевых аргументов по совпадающим именам (порядок следования аргументов не имеет значения, так как сопоставление происходит по имени, а не по позиции)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Присваивание оставшихся неключевых аргументов кортежу *имя&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Присваивание оставшихся ключевых аргументов словарю **имя&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Присваивание стандартных значений не присвоенным аргументам&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Проверка, передается ли каждому аргументу только одно значение — если нет, тогда возникает ошибка&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Присваивание именам аргументов переданных для них объектов&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;При этом учитывается то, какие из аргументов могут быть присвоены только по ключевым словам. Аргументы с передачей только по ключевым словам должны указываться после *, но не могут указываться после &lt;em&gt;**аргументы&lt;/em&gt;. Также, конструкция ** не может появляться в списке аргументов сама по себе.&lt;/p&gt;

&lt;h2 id=&quot;примеры&quot;&gt;Примеры&lt;/h2&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# a обязательный, остальные нет
# предоставим значение a по позиции
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# предоставим значение a по ключу
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# переопределим все три значения
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# передадим a и переопределим c
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# такой вариант вызовет ошибку
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# это тоже неверно
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В данном примере все аргументы, которым присвоено стандартное значение, необязательны при вызове функции. Объекты можно передавать в функцию как по позиции, так и по ключу.&lt;/p&gt;

&lt;p&gt;Примеры с произвольным количеством аргументов:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Тоже для ключевых аргументов:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kwargs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kwargs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)):&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'a'&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'b'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Все вместе:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kwargs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kwargs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'a'&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'b'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Распаковка аргументов при вызове функции:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kwargs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'a'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'b'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'c'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kwargs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Естественно можно сочетать позиционные, ключевые и агрегированные аргументы&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'e'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Наконец, мы можем указать какие из аргументов могут быть использованы только как ключевые:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,)&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;TypeError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;missing&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;required&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;keyword&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;only&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argument&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'c'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Кроме того, для аргументов «только по ключу» можно задавать стандартные значения:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Аргументы «только по ключу» должны быть записаны после формы с произвольным количеством позиционных аргументов &lt;em&gt;*аргументы&lt;/em&gt; и перед формой с произвольным количеством ключевых аргументов &lt;em&gt;**аргументы&lt;/em&gt;.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'x'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'y'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;SyntaxError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;invalid&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;syntax&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;изменения-в-python-38&quot;&gt;Изменения в Python 3.8&lt;/h2&gt;

&lt;p&gt;В python 3.8 добавлена возможность указывать аргументы, которые могут быть переданы только как позиционные. Это выполняется с помощью маркера / который указывает, что все аргументы слева от него передаются исключительно как позиционные.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;TypeError&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Статья подготовлена на основе книги «Изучаем Python» Lutz, Mark&lt;/p&gt;</content><author><name>Klepikov Konstantin</name></author><category term="phyton" /><summary type="html">Статью я написал потому, что постоянно забываю как обращаться к аргументам функций в разных сложных случаях. Надоело гуглить — сделал сеье шпаргалк. Для упрощения ситуации речь пойдет про python 3.x.</summary></entry><entry><title type="html">Как преобразовать вложенные структуры JSON в массив Pandas на Python</title><link href="https://konstantinklepikov.github.io/2020/03/30/preprocessing-of-json-data-to-pandas-on-python.html" rel="alternate" type="text/html" title="Как преобразовать вложенные структуры JSON в массив Pandas на Python" /><published>2020-03-30T00:00:00+02:00</published><updated>2020-03-30T00:00:00+02:00</updated><id>https://konstantinklepikov.github.io/2020/03/30/preprocessing-of-json-data-to-pandas-on-python</id><content type="html" xml:base="https://konstantinklepikov.github.io/2020/03/30/preprocessing-of-json-data-to-pandas-on-python.html">&lt;p&gt;Наиболее часто встречаемая проблема — это вложенные структуры данных, которые поставляются в JSON формате по API. Пример таких структур можно посмотреть в статье &lt;a href=&quot;/2020/03/04/data-preprocessing-and-compression-in-machine-learning.html&quot;&gt;подготовка и оптимизация данных для задач машинного обучения&lt;/a&gt;. В большинстве случаев требуются дополнительные действия для того, чтобы развернуть вложения в двумерном виде. В этой статье я покажу как это сделать.&lt;/p&gt;

&lt;h2 id=&quot;вложенные-структуры-json-с-которыми-придется-повозиться&quot;&gt;Вложенные структуры JSON с которыми придется повозиться&lt;/h2&gt;

&lt;p&gt;Попробуем поработать с данными на примере публичного API Государственной Думы Российской Федерации. Сервис предоставляет сведения о членах обеих палат и законотворческой деятельности.&lt;/p&gt;

&lt;p&gt;Вот пример ответа по запросу о списке депутатов и сенаторов (в данном случае :token и :app_token заменяются на ключи в реальном запросе):&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;requests&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;json_object&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requests&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'http://api.duma.gov.ru/api/:token/deputies.json?app_token=:app_token'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Что содержалось в ответе?&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
{'id': '99100491',
  'name': 'Абдулатипов Рамазан Гаджимурадович',
  'position': 'Депутат ГД',
  'isCurrent': False,
  'factions': [{'id': '72100020',
    'name': 'Депутатская группа &quot;Российские регионы&quot;',
    'startDate': '1996-01-16',
    'endDate': '1997-11-12'},
   {'id': '72100024',
    'name': 'Фракция Всероссийской политической партии &quot;ЕДИНАЯ РОССИЯ&quot;',
    'startDate': '2011-12-04',
    'endDate': '2013-01-27'}]}
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В этом примере мы наблюдаем вложенный список по ключу factions, в который помещены два словаря, агрегирующих данные о вхождении депутата во фракции. Такое вложение развернуть сразу не получится. Ситуация осложняется еще и тем, что по части депутатов ключ factions отсутствует.&lt;/p&gt;

&lt;h2 id=&quot;как-преобразовать-json-в-pandas&quot;&gt;Как преобразовать json в Pandas?&lt;/h2&gt;

&lt;p&gt;Мы можем разобрать json-объект с помощью &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.json_normalize.html&quot;&gt;pandas.json_normalize&lt;/a&gt; — метода, который разбирает структурированные данные из JSON в табличный формат, а также &lt;a href=&quot;https://docs.python.org/3/library/json.html&quot;&gt;json.load&lt;/a&gt;, который десериализует текст или байткод, содержащий json-документ в python-объекты. Применим к нашему json-объекта.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;numpy&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pandas&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pd&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;json&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;extracted&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;json_normalize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;json_object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Как и предполагалось, данные по factions остались неразвернутыми.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;position&lt;/th&gt;
      &lt;th&gt;isCurrent&lt;/th&gt;
      &lt;th&gt;factions&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;99100491&lt;/td&gt;
      &lt;td&gt;Абдулатипов Рамазан Гаджимурадович&lt;/td&gt;
      &lt;td&gt;Депутат ГД&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;[{‘id’: ‘72100020’, ‘name’: ‘Депутатская группа “Российские регионы”’, ‘startDate’: ‘1996-01-16’, ‘endDate’: ‘1997-11-12’}, {‘id’: ‘72100024’, ‘name’: ‘Фракция Всероссийской политической партии “ЕДИНАЯ РОССИЯ”’, ‘startDate’: ‘2011-12-04’, ‘endDate’: ‘2013-01-27’}]&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Что бы разобрать вложенный список из factions для начала избавимся от пропусков&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;factions_with_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;json_object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factions_with_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;is_factions&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'factions'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_factions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;factions_with_id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Теперь развернем factions относительно айдишников депутатов (meta=’id’). Чтобы сохранить семантику в полученной таблице, будем использовать аргумент record_prefix=’factions.’, который добавим к вновь образуемым столбцам массива.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;factions_with_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;json_normalize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;factions_with_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                             &lt;span class=&quot;n&quot;&gt;record_path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'factions'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                             &lt;span class=&quot;n&quot;&gt;meta&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'id'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                             &lt;span class=&quot;n&quot;&gt;record_prefix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'factions.'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                             &lt;span class=&quot;n&quot;&gt;errors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ignore&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Нам удалось развернуть список словарей в полноценную таблицу:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;factions_with_id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;class 'pandas.core.frame.DataFrame'&amp;gt;
RangeIndex: 5031 entries, 0 to 5030
Data columns (total 5 columns):
factions.id           5031 non-null object
factions.name         5031 non-null object
factions.startDate    5031 non-null object
factions.endDate      5031 non-null object
id                    5031 non-null object
dtypes: object(5)
memory usage: 196.6+ KB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Теперь в исходном массиве удалим колонку factions и с помощью метода merge() добавим в массив развернутые данные.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;extracted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;drop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'factions'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;axis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'columns'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inplace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;summary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;extracted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;merge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;factions_with_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;how&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'outer'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;summary&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;class 'pandas.core.frame.DataFrame'&amp;gt;
Int64Index: 5703 entries, 0 to 5702
Data columns (total 8 columns):
id                    5703 non-null object
name                  5703 non-null object
position              5703 non-null object
isCurrent             5703 non-null bool
factions.id           5031 non-null object
factions.name         5031 non-null object
factions.startDate    5031 non-null object
factions.endDate      5031 non-null object
dtypes: bool(1), object(7)
memory usage: 362.0+ KB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Теперь все хорошо — данные извлечены и представлены в удобном, с точки зрения семантики, табличном виде:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;position&lt;/th&gt;
      &lt;th&gt;isCurrent&lt;/th&gt;
      &lt;th&gt;factions.id&lt;/th&gt;
      &lt;th&gt;factions.name&lt;/th&gt;
      &lt;th&gt;factions.startDate&lt;/th&gt;
      &lt;th&gt;factions.endDate&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;99100491&lt;/td&gt;
      &lt;td&gt;Абдулатипов Рамазан Гаджимурадович&lt;/td&gt;
      &lt;td&gt;Депутат ГД&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;72100020&lt;/td&gt;
      &lt;td&gt;Депутатская группа “Российские регионы”&lt;/td&gt;
      &lt;td&gt;1996-01-16&lt;/td&gt;
      &lt;td&gt;1997-11-12&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;99100491&lt;/td&gt;
      &lt;td&gt;Абдулатипов Рамазан Гаджимурадович&lt;/td&gt;
      &lt;td&gt;Депутат ГД&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;72100024&lt;/td&gt;
      &lt;td&gt;Фракция Всероссийской политической партии “ЕДИНАЯ РОССИЯ”&lt;/td&gt;
      &lt;td&gt;2011-12-04&lt;/td&gt;
      &lt;td&gt;2013-01-27&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name>Klepikov Konstantin</name></author><category term="ml-data" /><category term="phyton" /><category term="preprocessing" /><category term="machine-learning" /><category term="pandas" /><category term="json" /><summary type="html">Наиболее часто встречаемая проблема — это вложенные структуры данных, которые поставляются в JSON формате по API. Пример таких структур можно посмотреть в статье подготовка и оптимизация данных для задач машинного обучения. В большинстве случаев требуются дополнительные действия для того, чтобы развернуть вложения в двумерном виде. В этой статье я покажу как это сделать.</summary></entry><entry><title type="html">Подготовка и оптимизация данных для задач машинного обучения</title><link href="https://konstantinklepikov.github.io/2020/03/04/data-preprocessing-and-compression-in-machine-learning.html" rel="alternate" type="text/html" title="Подготовка и оптимизация данных для задач машинного обучения" /><published>2020-03-04T00:00:00+02:00</published><updated>2020-03-04T00:00:00+02:00</updated><id>https://konstantinklepikov.github.io/2020/03/04/data-preprocessing-and-compression-in-machine-learning</id><content type="html" xml:base="https://konstantinklepikov.github.io/2020/03/04/data-preprocessing-and-compression-in-machine-learning.html">&lt;p&gt;Эту статью я написал, как результат митапа, на котором мой доклад был посвящен проблемам оптимизации двумерных данных.&lt;/p&gt;

&lt;h2 id=&quot;проблема-неоптимизированных-данных&quot;&gt;Проблема неоптимизированных данных&lt;/h2&gt;

&lt;p&gt;С какими задачами можно столкнуться и зачем вообще питонисту работать с данными?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;компания собрала дату, «потому что это важно»&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;люди, которые проектировали «склад» данных уволились, сошли с ума или умерли&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;пришло время «извлечь из этого смыслы» и «применить кейсы»&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Это означает, что потребуется разобрать авгиевы конюшни данных и построить какие-то модели машинного обучения. И тут-то все как раз и вспоминают про Вас. При этом есть несколько нюансов:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;абсолютно никто не в курсе что значат все эти забавные числа и строки из базы данных&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;никого особо не интересует сколько это будет стоить в расчетах (кстати, как всегда, сделать надо было вчера)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;совершенно очевидно, что на эту задачу амазоновские инстансы за 100500 миллиардов долларов Вам не выделят&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Часто самым первым шагом после извлечения массива, является построение некой сырой модели данных. Тут можно применять множество подходов, таких как, к примеру, разведочный анализ. Важно, что на этом этапе приходится обращаться к большому объему информации и производить определенные манипуляции вручную, что обходится дорого по времени. &lt;strong&gt;Что делать?&lt;/strong&gt; Попробуем разобраться в приемах оптимизации на примере данных с kaggle-соревнования &lt;a href=&quot;https://www.kaggle.com/c/data-science-bowl-2019&quot;&gt;data-science-bowl-2019&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../assets/img/040320-01.png&quot; alt=&quot;data-science-bowl-2019&quot; title=&quot;data-science-bowl-2019&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Цель соревнования рассматривать не будем, нас интересует только формат данных. Особенностью этой конкретной задачи было то, что она была ограничена весьма скромными вычислительными ресурсам. А это как раз наш случай. В задаче использовался датасет, содержащий почти 12 млн строк. Для наглядности я буду использовать только 200 тыс.строк и не стану приводить в данной статье исходники или каким-то образом исследовать данные, т.к. правилами конкурса запрещено использование датасет в целях, не связанных с соревнованием. Если Вам интересно разобраться непосредственно с задачей data-science-bowl-2019, Вы всегда можете сделать это самостоятельно на &lt;a href=&quot;https://www.kaggle.com/c/data-science-bowl-2019&quot;&gt;kaggle.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;После загрузки и формирования дата-фрейма посмотрим на данные с помощью метода info() библиотеки pandas&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;df_train&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max_cols&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;class 'pandas.core.frame.DataFrame'&amp;gt;
RangeIndex: 200000 entries, 0 to 199999
Columns: 11 entries, installation_id to world
dtypes: int64(3), object(8)
memory usage: 16.8+ MB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Здесь мы сразу встречаем первую ошибку, которая довольно часто в дальнейшем стоит значительных временных затрат. Дело в том, что метод info() оценивает объем данных в дата-фрейме приблизительно — нам об этом намекает скромный значек “+” после значения задействованной памяти. Особенно этот перекос становится заметен, если данные содержат объекты с вложенными структурами. Посмотрим еще раз, но теперь глубже.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;df_train&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_usage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'deep'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max_cols&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;class 'pandas.core.frame.DataFrame'&amp;gt;
RangeIndex: 200000 entries, 0 to 199999
Columns: 11 entries, installation_id to world
dtypes: int64(3), object(8)
memory usage: 147.3 MB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Почти в десять раз больше! Очевидно, что 200 тыс. строк, которые составляют менее 2% всего объема предоставленных данных, весят слишком много и их обработка потребует ресурсных затрат. Построение же модели на всех данных может оказаться и вовсе невыполнимой задачей по потребляемой памяти.&lt;/p&gt;

&lt;p&gt;Заглянем внутрь (в качестве примера здесь и далее показаны несколько строк и заголовки колонок)&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;installation_id&lt;/th&gt;
      &lt;th&gt;event_id&lt;/th&gt;
      &lt;th&gt;game_session&lt;/th&gt;
      &lt;th&gt;timestamp&lt;/th&gt;
      &lt;th&gt;event_data&lt;/th&gt;
      &lt;th&gt;event_count&lt;/th&gt;
      &lt;th&gt;event_code&lt;/th&gt;
      &lt;th&gt;game_time&lt;/th&gt;
      &lt;th&gt;title&lt;/th&gt;
      &lt;th&gt;type&lt;/th&gt;
      &lt;th&gt;world&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0001e90f&lt;/td&gt;
      &lt;td&gt;27253bdc&lt;/td&gt;
      &lt;td&gt;45bb1e1b6b50c07b&lt;/td&gt;
      &lt;td&gt;2019-09-06T17:53:46.937Z&lt;/td&gt;
      &lt;td&gt;{“event_code”: 2000, “event_count”: 1}&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;2000&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;Welcome to Lost Lagoon!&lt;/td&gt;
      &lt;td&gt;Clip&lt;/td&gt;
      &lt;td&gt;NONE&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0001e90f&lt;/td&gt;
      &lt;td&gt;77261ab5&lt;/td&gt;
      &lt;td&gt;0848ef14a8dc6892&lt;/td&gt;
      &lt;td&gt;2019-09-06T17:54:56.302Z&lt;/td&gt;
      &lt;td&gt;{“version”:”1.0”,”event_count”:1,”game_time”:0,”event_code”:2000}&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;2000&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;Sandcastle Builder (Activity)&lt;/td&gt;
      &lt;td&gt;Activity&lt;/td&gt;
      &lt;td&gt;MAGMAPEAK&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Часть данных являются числовыми, часть объектами. Как минимум одна серия имеет неограниченно вложенную структуру. Нам явно нужно привести данные к некоему единому виду.&lt;/p&gt;

&lt;h2 id=&quot;почему-нам-вообще-может-понадобиться-приводить-данные-к-какому-то-виду&quot;&gt;Почему нам вообще может понадобиться приводить данные к какому-то виду&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;большинство алгоритмов ML требует предварительной подготовки данных, например, приведение к числовому виду&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;часто данные нужно дополнительно привести к определенному виду для того чтобы срослась математика, например, нормализовать или привести к логарифмическому масштабу&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;машинное обучение точно плохо понимает неразобранные составные объекты&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;для большинства алгоритмов сложность по пространству/времени в основном сосредоточена на построении модели. Это хорошо для продакшена, но сильно увеличивает расходы на поиск решения&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Попробуем «разобрать» json-подобный объект, находящийся в колонке event_data. Для этого воспользуемся &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.json_normalize.html&quot;&gt;pandas.json_normalize&lt;/a&gt;, который разбирает структурированные данные из JSON в табличный формат, а также &lt;a href=&quot;https://docs.python.org/3/library/json.html&quot;&gt;json.load&lt;/a&gt;, который десериализует текст или байткод, содержащий json-документ в python-объекты. Чтобы применить эти методы ко всей серии, воспользуемся &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.apply.html&quot;&gt;DataFrame.apply&lt;/a&gt; (метод не сильно быстрый, но нам требуется выполнить эту операцию всего один раз, поэтому, в данном случае, время смело приносим в жертву).&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# json unpack
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;df_train_extracted&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;json_normalize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;df_train&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'event_data'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loads&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В результате у нас получилось довольно прилично новых признаков (приведено сокращенно)&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;df_train_extracted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;verbose&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;class 'pandas.core.frame.DataFrame'&amp;gt;
RangeIndex: 200000 entries, 0 to 199999
Data columns (total 136 columns):
event_code                  int64
event_count                 int64
version                     object
game_time                   float64
description                 object
...
gate.column                 float64
gate.side                   object
dinosaur_weight             float64
dinosaur_count              float64
chests                      object
dtypes: float64(64), int64(2), object(70)
memory usage: 207.5+ MB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Проблема заключается в том, что нам не удалось полностью разобрать json-подобные объекты, т.к. на самом деле они не отвечают стандарту json. Например, вот эти колонки остались неразобранными:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;flower&lt;/th&gt;
      &lt;th&gt;flowers&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0.0&lt;/td&gt;
      &lt;td&gt;[0, 0, 0, 0, 0]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0.0&lt;/td&gt;
      &lt;td&gt;[0, 0, 0, 0, 8]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0.0&lt;/td&gt;
      &lt;td&gt;[8, 8, 8, 7, 8]&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;shels&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;[2, 3, 1]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[2, 3, 2, 1]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[2, 3, 2, 3, 2]&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;bottles&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;[{‘color’: ‘blue’, ‘amount’: 2}, {‘color’: ‘blue’, ‘amount’: 1}, {‘color’: ‘purple’, ‘amount’: 2…&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[{‘color’: ‘blue’, ‘amount’: 2}, {‘color’: ‘blue’, ‘amount’: 1}, {‘color’: ‘purple’, ‘amount’: 2…&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[{‘color’: ‘blue’, ‘amount’: 2}, {‘color’: ‘blue’, ‘amount’: 1}, {‘color’: ‘purple’, ‘amount’: 2…&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;castles_placed&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;[]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[{‘size’: 3, ‘position’: {‘x’: 567, ‘y’: 484, ‘stage_width’: 1015, ‘stage_height’: 762}}]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[{‘size’: 3, ‘position’: {‘x’: 567, ‘y’: 484, ‘stage_width’: 1015, ‘stage_height’: 762}}, {‘size…&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Мы видим списки с пропусками, пустые списки, списки неравной длины, списки словарей, а так-же списки с разным числом вложенных вловарей и даже кортежи списков. Все это возникло потому, что так когда-то кому-то было удобно складировать эти данные в базу данных. Теперь это придется разобрать вручную. Данная задача выходит за рамки этой статьи. Тут я всего лишь демонстрирую то, с чем зачастую можно столкнуться при обработке данных.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Что еще можно встретить?&lt;/strong&gt; Строки, пустые множества и словари. Булевые и другие значение, в том числе записанные как строки или с ошибками, например так: ‘NONE’, ‘nul’, ‘none’, ‘0’ и т.п., false и true, ‘False’, ‘True’, ‘Yes’, ‘No’ и т.д. - список сильно неполный. Все это требует детального исследования и разбора.&lt;/p&gt;

&lt;p&gt;К тому же, не все данные стоит разбирать. Иногда можно встретить готовые векторы, например координаты или списки каких-то сгруппированных значений.&lt;/p&gt;

&lt;p&gt;В итоге, что с памятью?&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;df_train_extracted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_usage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'deep'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max_cols&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;class 'pandas.core.frame.DataFrame'&amp;gt;
RangeIndex: 200000 entries, 0 to 199999
Columns: 136 entries, event_code to chests
dtypes: float64(64), int64(2), object(70)
memory usage: 543.8 MB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Мы еще сильнее потеряли в потреблении памяти! А данные еще копать и копать…&lt;/p&gt;

&lt;h2 id=&quot;битва-за-память&quot;&gt;Битва за память&lt;/h2&gt;

&lt;p&gt;На самом деле Pandas группирует и хранит “столбцы” блоками, разбитыми по типам. Иными словами float, int и objects хранятся раздельно, причем оптимизировано, без индексов. С числами все просто — столбцы в блоке объединяются в многомерный массив NumPy. При запросе значения происходит сопоставление индекса с массивом. С объектами немного сложнее. Все это означает, что &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/getting_started/basics.html#basics-dtypes&quot;&gt;разные объекты&lt;/a&gt; по-разному используют память.&lt;/p&gt;

&lt;p&gt;Поработаем с разными типами объектов отдельно.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;numerics_part&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;df_train_extracted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;select_dtypes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'number'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;objects_part&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;df_train_extracted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;select_dtypes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'object'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Для начала разберемся с наименьшим злом — с числами&lt;/strong&gt;. В Pandas используются подтипы int8, int16, int32, int64, float16, float32, float64. В нашем случае в результате сравнения при извлечении, числа оказались в наиболее затратном по памяти формате.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;numerics_part&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_usage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'deep'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;class 'pandas.core.frame.DataFrame'&amp;gt;
RangeIndex: 200000 entries, 0 to 199999
Data columns (total 66 columns):
event_code                  200000 non-null int64
event_count                 200000 non-null int64
game_time                   196724 non-null float64
total_duration              34617 non-null float64
duration                    67500 non-null float64
...
end_position                4 non-null float64
gate.row                    832 non-null float64
gate.column                 832 non-null float64
dinosaur_weight             1547 non-null float64
dinosaur_count              1550 non-null float64
dtypes: float64(64), int64(2)
memory usage: 100.7 MB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Изменим эту ситуацию и вот как: получим минимальное и максимальное значение в серии, затем сравним его с машинными лимитами для типов Numpy, после чего заменим на наименьшее.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;numerics&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'int16'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'int32'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'int64'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'float16'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'float32'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'float64'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;columns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;col_type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dtypes&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col_type&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numerics&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;c_min&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;c_max&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col_type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'int'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;# последовательно сравниваем от наименьшего инта начиная с np.int8
&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;# наверх и переопределяем тип для серии
&lt;/span&gt;            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c_min&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iinfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;min&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c_max&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iinfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;astype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c_min&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iinfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;min&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c_max&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iinfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;# и т.д.
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;# аналогично для float
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Мы выполнили самопальный вариант понижающего преобразования, выиграв 74.4Mb.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;numerics_part&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_usage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'deep'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max_cols&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;class 'pandas.core.frame.DataFrame'&amp;gt;
RangeIndex: 200000 entries, 0 to 199999
Columns: 66 entries, event_code to dinosaur_count
dtypes: float16(61), float32(3), int16(2)
memory usage: 26.3 MB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Но у нас все еще есть проблема:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;flower&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2.0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Оказывается, везде в датасете использовано число с плавающей точкой, хотя на самом деле никакой потребности в этом нет - в этих данных все числа целые. Исправим эту ситуацию:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;numerics_part&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fillna&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inplace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;numerics_part&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numerics_part&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;astype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В данном случае мы заменили все пропуски в данных на -1, что открыло для нас возможность применить преобразование типов. Прием замены пропусков на число довольно часто встречается — обычно выбирают число, которое не встречается в данных, к примеру -9999. В нашем случае в данных вообще нет отрицательных чисел, поэтому мы просто взяли наименьшее кешированное, что бы сэкономить и тут. К тому же этот трюк окажется полезен в будущем. Смотрим на результат преобразования:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;numerics_part&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_usage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'deep'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;class 'pandas.core.frame.DataFrame'&amp;gt;
RangeIndex: 200000 entries, 0 to 199999
Data columns (total 66 columns):
event_code                  200000 non-null int16
event_count                 200000 non-null int16
game_time                   200000 non-null int32
total_duration              200000 non-null int32
duration                    200000 non-null int32
...
end_position                200000 non-null int8
gate.row                    200000 non-null int8
gate.column                 200000 non-null int8
dinosaur_weight             200000 non-null int8
dinosaur_count              200000 non-null int8
dtypes: int16(9), int32(4), int8(53)
memory usage: 16.6 MB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Итого, по числам нам удалось сэкономить 83.5% по памяти! Неплохо.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Переходим к объектам&lt;/strong&gt;. Тип object в Pandas хранит строковое представление. Строки хранятся фрагментировано - значение в ячейке по сути является указателем. При этом резервируется много памяти и это для нас плохо.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;objects_part&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_usage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'deep'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max_cols&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;class 'pandas.core.frame.DataFrame'&amp;gt;
RangeIndex: 200000 entries, 0 to 199999
Columns: 70 entries, version to chests
dtypes: object(70)
memory usage: 443.1 MB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Pandas предоставляет подтип category, который отображает строковые данные на индекс в int, а это то, что нам нужно, т.к. данные будут храниться не в виде указателя, а в виде словаря, в котором целочисленным значениям сопоставлены уникальным значениям данных. Перегоним наши объекты в «категории»:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# subtype categoty
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;object_to_category&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;part&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;converted_objects_part&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DataFrame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;unconverted_objects_part&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DataFrame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;part&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;part&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;columns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;unic&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;part&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unique&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unic&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.05&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;converted_objects_part&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[:,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;part&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;astype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'category'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;converted_objects_part&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[:,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;part&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;TypeError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;# unhashable objects can't be categorised
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;unconverted_objects_part&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[:,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;part&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;converted_objects_part&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unconverted_objects_part&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Мы отбросим часть объектов, т.к. договорились ранее не работать с нераспакованной частью json&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;converted_objects_part&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unconverted_objects_part&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;object_to_category&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects_part&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;converted_objects_part&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_usage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'deep'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;class 'pandas.core.frame.DataFrame'&amp;gt;
RangeIndex: 200000 entries, 0 to 199999
Data columns (total 39 columns):
version                2345 non-null category
description            69717 non-null category
identifier             68610 non-null category
...
crystal_id             2090 non-null category
location               1180 non-null category
gate.side              832 non-null category
dtypes: category(39)
memory usage: 7.9 MB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Обратите внимание, что мы сами управляем какие именно объекты представлять в виде категорий через отношение количества уникальных значений к общему количеству значений в серии. Теперь посмотрим объем нераспакованных данных и сложим с оптимизированными распакованными:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;unconverted_objects_part&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_usage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'deep'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max_cols&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;class 'pandas.core.frame.DataFrame'&amp;gt;
RangeIndex: 200000 entries, 0 to 199999
Columns: 31 entries, castles_placed to chests
dtypes: object(31)
memory usage: 193.0 MB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;193.0MB + 7.9MB — нам удалось сэкономить 242.2MB, больше половины. Если мы применим наш метод ко всему дата-сету, то мы увидим, что не все объекты укладываются в наш формат категорий. часть объектов имеет слишком большое число уникальных значений (хешы, айдишники и т.д.) и есть смысл оставить их в объектах.&lt;/p&gt;

&lt;p&gt;Кстати, при определении подтипа category, пропуски в списке заменяются на дефолтное значение -1. Это очень удачно совпало с принятым нами ранее решением :)&lt;/p&gt;

&lt;p&gt;Отдельно стоит отметить колонку timestamp. Это временная метка и в неоптимизированном виде она тоже занимает избыточное пространство.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;df_train&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'timestamp'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0         2019-09-06T17:53:46.937Z
1         2019-09-06T17:54:17.519Z
2         2019-09-06T17:54:56.302Z
...
199997    2019-08-02T00:06:37.107Z
199998    2019-08-02T00:06:38.480Z
199999    2019-08-02T00:06:40.684Z
Name: timestamp, Length: 200000, dtype: object
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Временную метку оптимизируем с помощью функции pandas &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.to_datetime.html&quot;&gt;pd.to_datetime&lt;/a&gt;. Параметр format позволяет задать тип представления временной отметки. Дефолтный вот такой: “%d/%m/%Y”. Теперь метка будет выглядеть так:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;df_train&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'timestamp'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to_datetime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;df_train&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'timestamp'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;df_train&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'timestamp'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0        2019-09-06 17:53:46.937000+00:00
1        2019-09-06 17:54:17.519000+00:00
2        2019-09-06 17:54:56.302000+00:00
...
199997   2019-08-02 00:06:37.107000+00:00
199998   2019-08-02 00:06:38.480000+00:00
199999   2019-08-02 00:06:40.684000+00:00
Name: timestamp, Length: 200000, dtype: datetime64[ns, UTC]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В этом оптимизированном виде мы сэкономим дополнительные 14Mb памяти.&lt;/p&gt;

&lt;p&gt;В завершении операций по оптимизации необходимо данные сериализовать. Сделать это можно, к примеру, с помощью стандартного модуля shelve. Чуть позже, в отдельной статье я расскажу про сложности и пути их решения, которые могут возникнуть при сериализации.&lt;/p&gt;

&lt;h3 id=&quot;что-еще-можно-сделать&quot;&gt;Что еще можно сделать&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;распаковать вложенности&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;не все нужно распаковывать - кое-что это готовые вектора, кое-что можно пересчитать в скаляры&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;избавиться от разреженности либо оптимизировать разреженные данные&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Кроме того, можно не ограничиться представлением, а закодировать столбцы цифрами. Есть методы в самом Pandas. Я рекомендую использовать внешний модуль category_encoders:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;позволяет кодировать категории в цифры разными методами (их там около 20)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;можно кодировать полуструктурированные и неструктурированные данные&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;можно сильно сократить выход по памяти за счет target encoding&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;работает в стиле scikit-learn пайплайнов&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;возвращает как Numpy массив, так и Pandas датафрейм&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Как кодировать категории с помощью category_encoders читайте в &lt;a href=&quot;/2019/10/28/data-preprocessing-category-encoders.html&quot;&gt;этой статье&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Ну и, наконец, можно перегнать все в Numpy! :)&lt;/p&gt;</content><author><name>Klepikov Konstantin</name></author><category term="ml-data" /><category term="phyton" /><category term="preprocessing" /><category term="machine-learning" /><category term="pandas" /><category term="json" /><summary type="html">Эту статью я написал, как результат митапа, на котором мой доклад был посвящен проблемам оптимизации двумерных данных.</summary></entry><entry><title type="html">Термины статистики, которые пригодятся для data science. Часть 2</title><link href="https://konstantinklepikov.github.io/2020/01/16/statistics-terms-for-data-science-part-two.html" rel="alternate" type="text/html" title="Термины статистики, которые пригодятся для data science. Часть 2" /><published>2020-01-16T00:00:00+02:00</published><updated>2020-01-16T00:00:00+02:00</updated><id>https://konstantinklepikov.github.io/2020/01/16/statistics-terms-for-data-science-part-two</id><content type="html" xml:base="https://konstantinklepikov.github.io/2020/01/16/statistics-terms-for-data-science-part-two.html">&lt;p&gt;Первую часть статьи можно найти &lt;a href=&quot;/2019/12/15/statistics-terms-for-data-science.html&quot;&gt;по ссылке&lt;/a&gt;. Источником для данного материала является книга &lt;a href=&quot;https://www.oreilly.com/library/view/practical-statistics-for/9781491952955/&quot;&gt;Practical Statistics for Data Scientists&lt;/a&gt;, Andrew Bruce, Peter Bruce&lt;/p&gt;

&lt;h2 id=&quot;выборки-и-распределения-данных&quot;&gt;Выборки и распределения данных&lt;/h2&gt;

&lt;p&gt;В статистике используется понятие &lt;strong&gt;популяции (population)&lt;/strong&gt; или &lt;strong&gt;генеральной совокупности&lt;/strong&gt; — это вся совокупность данных, объединенная некой общей описательной функцией. Часто популяция является теоретической совокупностью данных и не обязательно относится к области фактических измерений или сбора данных. Тогда &lt;strong&gt;выборка (sample)&lt;/strong&gt; — это некое подмножество данных из популяции. Используется обычная нотация множеств  &lt;strong&gt;&lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt;&lt;/strong&gt; размер популяции, а &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; размер выборки.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Случайный отбор (random sampling)&lt;/strong&gt; — получение выборки путем произвольного отбора примеров из популяции. Выборка, полученная в результате такого отбора, называется &lt;strong&gt;простой (simple)&lt;/strong&gt;. Если разрешено повторно отбирать в выборку ранее отобранный пример из популяции, такой отбор называется отбором &lt;strong&gt;с возвратом&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Стратифицированный случайный отбор (stratified sampling)&lt;/strong&gt; предполагает предварительное разбиение популяции на страты и случайный отбор примеров уже из страт.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Смещение выборки (sample bias)&lt;/strong&gt; — искажение или отклонение в структуре выборки от структуры популяции. Такое смещение возникает в результате ошибок измерения или отбора. Со смещением связывают несколько понятий, часто порождающих ошибки отбора. Во-первых, это &lt;strong&gt;прочесывание данных (data snooping)&lt;/strong&gt; — постоянное прочесывание данных с целью выявления неких закономерностей. Во-вторых, это &lt;strong&gt;эффект бескрайнего поиска (vast search effect)&lt;/strong&gt;, смещение, вызванное, многократным моделированием данных либо моделирование с большим количеством прогнозируемых переменных. В-третьих, регрессия к среднему значению, когда предельные примеры имеют свойство сопровождаться более центральными.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Распределение данных (data distribution)&lt;/strong&gt; — частотное распределение значений данных в выборке. Очевидно, что распределения статистики и данных могут отличаться.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Выборочная статистика (sample statistic)&lt;/strong&gt; — некий показатель, вычисляемый для выборки. Статистика характеризуется &lt;strong&gt;выборочным распределением (sampling distribution)&lt;/strong&gt; — частотным распределением статистики на многочисленных выборках. Мерой оценки выборочной статистики является &lt;strong&gt;стандартная ошибка (standard error)&lt;/strong&gt; — стандартное отклонение выборочной статистики на многочисленных выборках. &lt;script type=&quot;math/tex&quot;&gt;S{\tiny x} = \frac{s}{\sqrt{n}}&lt;/script&gt;, где &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; стандартное отклонение, а &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; размер выборки.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Центральная предельная теорема статистики (central limit error)&lt;/strong&gt;: сумма достаточно большого количества слабо зависимых случайных величин, имеющих примерно одинаковые масштабы (ни одно из слагаемых не доминирует, не вносит в сумму определяющего вклада), имеет распределение, близкое к нормальному. Для статистики это может означать, что с ростом размера выборок, средние значения, распределение статистик будет приближаться к нормальному. Смотри &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_limit_theorem&quot;&gt;подробную статью&lt;/a&gt; на википедии.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Бутстрап выборка (bootstrap sample)&lt;/strong&gt; — метод, при котором из выборки многократно получают повторные выборки с возвратом и вычисляют для каждой из них статистику. Является эффективным способом оценки выборочной статистики и существенно расширяет возможности оценки выборки.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Повторный отбор (resampling)&lt;/strong&gt; — бутстрап с перестановкой.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ошибка (error)&lt;/strong&gt; — разница между примером данных (точкой) и предсказанием.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Стандартизация (standardize) или нормализация&lt;/strong&gt; — вычитание среднего значения выборки с последующим делением на стандартное отклонение. При этом результат стандартизации для каждой точки данных называется &lt;strong&gt;z-оценкой (z-score)&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Нормальное или гаусово распределение&lt;/strong&gt; — &lt;a href=&quot;https://en.wikipedia.org/wiki/Normal_distribution&quot;&gt;распределение&lt;/a&gt;, заданное функцией, совпадающей с функцией плотности вероятности. &lt;strong&gt;Стандартное нормальное распределение (standard normal)&lt;/strong&gt; — нормальное распределение со средним, равным 0 и стандартным отклонением, равным 1.&lt;/p&gt;

&lt;p&gt;В отличие от нормального распределения, скошенные распределения имеют длинные хвосты, в которых относительно предельные значения встречаются с низкой частотой. В скошенных распределениях один хвост длиннее другого (ассиметрия).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Биномиальное распределение (binomial distribution)&lt;/strong&gt; — частотное распределение числа успехов в заданном числе испытаний с определенной вероятностью успеха в каждом испытании, где понятие «успех» соответствует целевому результату испытания, «испытание» является определенным событием с дискретным исходом, а понятие «биномиальный» предполагает, что есть только два исхода. &lt;a href=&quot;https://en.wikipedia.org/wiki/Binomial_distribution&quot;&gt;См. статью&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Распределение Пуассона&lt;/strong&gt; — грубо говоря, это частотное распределение числа событий за определенное фиксированное время. Более подробно в &lt;a href=&quot;https://en.wikipedia.org/wiki/Poisson_distribution&quot;&gt;статье на википедии&lt;/a&gt;. В данном распределении определяющим является &lt;script type=&quot;math/tex&quot;&gt;\lambda&lt;/script&gt; — интенсивность, с которой происходят события.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Экспоненциальное распределение&lt;/strong&gt; — частотное распределение времени между событиями, при условии что &lt;script type=&quot;math/tex&quot;&gt;\lambda&lt;/script&gt; постоянна (&lt;a href=&quot;https://en.wikipedia.org/wiki/Exponential_distribution&quot;&gt;смотри статью&lt;/a&gt;). В распределении Вейбула допускается смещение &lt;script type=&quot;math/tex&quot;&gt;\lambda&lt;/script&gt; во времени.&lt;/p&gt;</content><author><name>Klepikov Konstantin</name></author><category term="statistics" /><category term="data-science" /><category term="machine-learning" /><summary type="html">Первую часть статьи можно найти по ссылке. Источником для данного материала является книга Practical Statistics for Data Scientists, Andrew Bruce, Peter Bruce</summary></entry><entry><title type="html">Краткий справочник по терминам статистики, которые пригодятся для data science. Часть 1</title><link href="https://konstantinklepikov.github.io/2019/12/15/statistics-terms-for-data-science.html" rel="alternate" type="text/html" title="Краткий справочник по терминам статистики, которые пригодятся для data science. Часть 1" /><published>2019-12-15T00:00:00+02:00</published><updated>2019-12-15T00:00:00+02:00</updated><id>https://konstantinklepikov.github.io/2019/12/15/statistics-terms-for-data-science</id><content type="html" xml:base="https://konstantinklepikov.github.io/2019/12/15/statistics-terms-for-data-science.html">&lt;p&gt;В данной статье кратко пройду по терминологии из практической статистики и ее применеии в data science. Термины приводятся в упрощенном виде, исключительно для понимания общих принципов. Источник для данной компиляции — книга &lt;a href=&quot;https://www.oreilly.com/library/view/practical-statistics-for/9781491952955/&quot;&gt;Practical Statistics for Data Scientists&lt;/a&gt;, Andrew Bruce, Peter Bruce&lt;/p&gt;

&lt;h2 id=&quot;основные-оценки&quot;&gt;Основные оценки&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Среднее (mean)&lt;/strong&gt; — сумма значений, разделенная на их количество. &lt;script type=&quot;math/tex&quot;&gt;\bar{x} = \frac{\underset{i}{\overset{n}\sum}\ x{\tiny i}}{\quad n \quad}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Среднее усеченное (trimmed mean)&lt;/strong&gt; — среднее, считаемое после отбрасывания определенного количества значений с обоих концов последовательности. &lt;script type=&quot;math/tex&quot;&gt;\bar{x} = \frac{\underset{i=p+1}{\overset{n-p}\sum}\ x{\tiny i}}{\quad n - 2p \quad}&lt;/script&gt;, где &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; — количество отбрасываемых значений. Устраняет влияние предельных значений.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Среднее взвешенное (weighted mean)&lt;/strong&gt; — среднее произведений всех значений на их веса, деленное на сумму всех весов. &lt;script type=&quot;math/tex&quot;&gt;\bar{x}{\tiny w} = \frac{\underset{i=p+1}{\overset{n-p}\sum}\ w{\tiny i} x{\tiny i}}{\underset{i}{\overset{n}\sum}\ w{\tiny i}}&lt;/script&gt;. Используется для усреднения данных, имеющих внутреннюю неоднородность.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Медиана (median)&lt;/strong&gt; — значение, расположенное посередине сортированного списка данных. Если число данных четное, за медиану принимается среднее арифметическое двух значений, которые делят сортированные данные на две половины. Взвешенная медиана (weighted median) — данные сортируются, затем вычисляется сумма весов таким образом, чтобы для левой и правой частей данных сумма весов была одинаковой.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Выброс (outlier)&lt;/strong&gt; — значение данных, сильно удаленное от основного кластера значений. Оценка, на которую не влияют выбросы, называется робастной (robust). Медиана - робастная оценка.&lt;/p&gt;

&lt;p&gt;На практике медиана будет встречаться в ML в масштабных задачах реже неробастных оценок. Обычно данных достаточно для построения несмещенных моделей и влияние выбросов не критично. «Усечение» — прием, который частенько можно встретить и используется он для повышения обобщающей способности модели.&lt;/p&gt;

&lt;h2 id=&quot;вариабельность&quot;&gt;Вариабельность&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Отклонение (deviation)&lt;/strong&gt; — разница между наблюдаемым значением и оценкой центрального положения (например, средним).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Среднее абсолютное отклонение (mean absolute deviation)&lt;/strong&gt; — среднее взятых по модулю (абсолютных) значений отклонений от центрального положения. &lt;script type=&quot;math/tex&quot;&gt;mad = \frac{\underset{i=1}{\overset{n}\sum}\ \vert x{\tiny i} - \bar{x}\vert}{n}&lt;/script&gt;. Еще известно как «манхэттенская норма» или &lt;script type=&quot;math/tex&quot;&gt;l1&lt;/script&gt;. Является робастной оценкой.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Дисперсия (variance)&lt;/strong&gt; — среднее квадратических отклонений. &lt;script type=&quot;math/tex&quot;&gt;var = \frac{\underset{i=1}{\overset{n}\sum}\ (x{\tiny i} - \bar{x})^2}{n}&lt;/script&gt; Дисперсия чувствительна к выбросам.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Стандартное отклонение (standard deviation)&lt;/strong&gt;  — квадратный корень из дисперсии или «евклидова норма» или &lt;script type=&quot;math/tex&quot;&gt;l2&lt;/script&gt; норма. Так же, как и дисперсия, чувствительно к выбросам.&lt;/p&gt;

&lt;p&gt;Для вычисления несмещенной оценки отклонений используется деление на &lt;script type=&quot;math/tex&quot;&gt;n-1&lt;/script&gt; вместо &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;. На практике в ML не сильно важно — смещенная оценка или не смещенная, так как данных обычно очень много.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Медианное абсолютное отклонение от медианы (median absolute deviation from median)&lt;/strong&gt; — робастная оценка вариабельности, медиана абсолютных значений отклонений от медианы.&lt;/p&gt;

&lt;h3 id=&quot;порядковые-статистики&quot;&gt;Порядковые статистики&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Размах (range)&lt;/strong&gt; — разница между самым большим и самым маленьким значением в наборе данных.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Процентиль (percentile)&lt;/strong&gt; — значение, при котором &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; процентов значений принимает данное значение либо меньше, а &lt;script type=&quot;math/tex&quot;&gt;(100-p)&lt;/script&gt; процентов — данное значение или больше.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Межквартальный размах (IQR)&lt;/strong&gt; — разница между 25-м и 75-м процентилем.&lt;/p&gt;

&lt;p&gt;Расчет процентилей — затратная задача, так как требует сортировки всех данных. Для больших наборов используется приблизительный процентиль (например, алгоритм Zhang-Wang-2007).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Мода (mode)&lt;/strong&gt; — наиболее часто встречающееся значение в наборе данных.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Математическое ожидание (expected value)&lt;/strong&gt; — среднее (взвешенное по вероятностям возможных значений) значение случайной величины. Очень упрощая, принимается мат.ожидание так: каждый исход события умножается на вероятность его наступления, эти значения суммируются. Более подробно во всех смыслах икрмин неплохо &lt;a href=&quot;https://en.wikipedia.org/wiki/Expected_value&quot;&gt;описан в википедии&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;корреляция-и-ковариация&quot;&gt;Корреляция и ковариация&lt;/h3&gt;

&lt;p&gt;Корелляция переменных имеет большое значение в построении моделей ML. Переменная x считается коррелирующей с переменной y, если изменение первой можно соотнести с изменениями второй. При оценке корреляции определяют направленность — переменные положительно кореллируют, если большим значениям x соответствуют большие значения y, а отрицательно, если наоборот.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Коэффициент корреляции (correlation coefficient)&lt;/strong&gt; — метрический показатель, измеряющий степень связи переменных (в диапазоне от -1 до +1). При этом смещение в отрицательную область говорит об отрицательной корреляции, в положительную о положительной, а близость к 0 об отсутствии. Часто говорят, что наблюдается слабая или сильная корреляция. &lt;script type=&quot;math/tex&quot;&gt;r = \frac{\underset{i=1}{\overset{n}\sum}\ (x{\tiny i} - \bar{x})(y{\tiny i} - \bar{y})}{(n-1) s{\tiny x} s{\tiny y}}&lt;/script&gt;. В данном случае мы имеем дело с коэфициентом корреляции Пирсона, где вверху учитывается сумма отклонений от среднего для двух переменных, а внизу произведение их стандартных отклонений.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ковариация&lt;/strong&gt; позволяет определить наличие связи между переменными, но не показывает насколько сильно они связаны. В формуле коэффициента корреляции Пирсона ковариация: &lt;script type=&quot;math/tex&quot;&gt;\frac{\underset{i=1}{\overset{n}\sum}\ (x{\tiny i} - \bar{x})(y{\tiny i} - \bar{y})}{(n-1)} = cov&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;В предварительном анализе данных для построения моделей можно встретить &lt;strong&gt;корреляционную матрицу&lt;/strong&gt; — двумерный массив, в котором строки и столбцы представлены переменными, а значение ячеек коэфициентами корреляции. Такая матрица позволяет установить нелинейную связь переменных, когда коэфциент корреляции становится бесполезным.&lt;/p&gt;</content><author><name>Klepikov Konstantin</name></author><category term="statistics" /><category term="data-science" /><category term="machine-learning" /><summary type="html">В данной статье кратко пройду по терминологии из практической статистики и ее применеии в data science. Термины приводятся в упрощенном виде, исключительно для понимания общих принципов. Источник для данной компиляции — книга Practical Statistics for Data Scientists, Andrew Bruce, Peter Bruce</summary></entry><entry><title type="html">Подготовка данных: кодирование категориальных признаков</title><link href="https://konstantinklepikov.github.io/2019/10/28/data-preprocessing-category-encoders.html" rel="alternate" type="text/html" title="Подготовка данных: кодирование категориальных признаков" /><published>2019-10-28T00:00:00+02:00</published><updated>2019-10-28T00:00:00+02:00</updated><id>https://konstantinklepikov.github.io/2019/10/28/data-preprocessing-category-encoders</id><content type="html" xml:base="https://konstantinklepikov.github.io/2019/10/28/data-preprocessing-category-encoders.html">&lt;p&gt;В статье «&lt;a href=&quot;/2019/10/08/scikit-learn-preprocessing.html&quot;&gt;особенности препроцессинга данных в scikit-learn&lt;/a&gt;» разбирались особенности кодирования признаков с помощью библиотеки scikit-learn. К сожалению, набор инструментов scikit-learn довольно скромный.&lt;/p&gt;

&lt;p&gt;Часто данные содержат множественные категориальные признаки с разными представлениями категорий. В некоторых случаях категорий оказывается сравнительно много, по отношению к общему объему данных. Иногда значения в категориальных признаках имеют различные распределения, могут иметь как явный, так и неочевидный порядок. Все это не добавляет энтузиазма во время предварительной обработки.&lt;/p&gt;

&lt;p&gt;К счастью, есть готовые решения, например библиотека &lt;strong&gt;&lt;a href=&quot;https://contrib.scikit-learn.org/categorical-encoding/&quot;&gt;Category Encoders&lt;/a&gt; (CE)&lt;/strong&gt;, предоставляющая широкий набор кодировщиков категориальных признаков.&lt;/p&gt;

&lt;h2 id=&quot;какие-преимущества-у-ce&quot;&gt;Какие преимущества у CE&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Наверное, самое основное — это полная совместимость с scikit-learn. Доступны методы fit, fit_transform, get_params, set_params и transform. На основе CE можно строить пайплайны в scikit-learn.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Поддержка numpy и pandas. Что важно — pandas dataframe можно получить и на выходе кодировщика. Иногда это весьма полезно, особенно когда нужно выполнить выборочное кодирование. Это позволяет не городить самодельный забор из кодировщиков, а использовать CE непосредственно в последовательном пайплайне scikit-learn.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Есть возможность задать маску для кодирования, т.е. сделать выборочное кодирование&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Можно отбросить часть данных&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Спроектированный кодировщик отлично портируется на рабочие данные.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;какие-задачи-можно-решать-с-помощью-ce&quot;&gt;Какие задачи можно решать с помощью CE&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;кодирование номинальных признаков (nominal) — признаки, порядок которых не определен (часто в табличных данных к таким признакам относятся распределения по цветам или по городам)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;кодирование упорядоченных признаков (ordinal) — признаки, порядок которых можно считать определенным (например, распределение по яркости)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;В CE можно кодировать бинарные признаки, упорядоченные по алфавиту или численному возрастанию признаки, а также географические, геометрические данные, данные о времени и другие структурированные данные. Единственное ограничение — решение не предоставляет собственного способа для создания масок для выборочного кодирования.&lt;/p&gt;

&lt;h2 id=&quot;что-имеется-в-наборе-ce&quot;&gt;Что имеется в наборе CE&lt;/h2&gt;

&lt;h3 id=&quot;contrast-coding&quot;&gt;Contrast Coding&lt;/h3&gt;

&lt;p&gt;Данный тип кодирование разбивает признак на уровни (в каждом только значения, относящиеся к одной категории). Затем для каждого уровня вычисляется некоторая статистика. Например, вот так это делается в &lt;a href=&quot;http://www.statsmodels.org/dev/contrasts.html&quot;&gt;statsmodels&lt;/a&gt;. Метод подходит для кодирования номинальных и частично упорядоченных признаков.&lt;/p&gt;

&lt;p&gt;В CE реализованы следующие кодеры:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Backward Difference Coding — сравнивается среднее для уровня со средним предыдущего уровня&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Helmert Coding — сравнивается среднее для уровня со средним для всех последующих уровней. Больше подходит для номинальных переменных.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Sum Coding — сравнивается среднее для уровня со средним для всех остальных уровней&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Polynomial Coding — используются линейные, квадратичные и кубические представления целевой категории. Подходит исключительно для упорядоченных признаков, интервалы между категориями которых одинаковы. Ну и довольно прожорлив по памяти.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Не реализованы:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Deviation Coding — более общий случай суммирующего кодирования, когда сравнение идет со всеми уровнями&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Dummy Coding — сравнение со средним значением на уровне&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Simple Coding — то же самое, что и Dummy Coding, только в качестве среднего принимается среднее всех значений фиксированного уровня&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Reverse Helmet Coding&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Forward Difference Coding&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Больше подробностей &lt;a href=&quot;https://stats.idre.ucla.edu/r/library/r-library-contrast-coding-systems-for-categorical-variables/&quot;&gt;смотри тут&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;target-based-coding&quot;&gt;Target-based Coding&lt;/h3&gt;

&lt;p&gt;Для кодирования переменных используются сведения о разметке (цели) дата-сета. Тут надо знать следующие понятия: &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt; общее число примеров, &lt;script type=&quot;math/tex&quot;&gt;y^+&lt;/script&gt; число примеров, отнесенных к «положительному» классу, &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; число примеров на уровне, &lt;script type=&quot;math/tex&quot;&gt;n^+&lt;/script&gt; число примеров уровня, отнесенных к положительному классу, &lt;script type=&quot;math/tex&quot;&gt;\alpha&lt;/script&gt; регуляризирующий параметр, &lt;script type=&quot;math/tex&quot;&gt;prior&lt;/script&gt; среднее значение цели. В CE реализованы:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Target Encoder. Переменная кодируется по формуле &lt;script type=&quot;math/tex&quot;&gt;x^k = prior*(1 - s)&lt;/script&gt; &lt;script type=&quot;math/tex&quot;&gt;+ s*\frac{n^+}{n}&lt;/script&gt;, где &lt;script type=&quot;math/tex&quot;&gt;s = \frac{1}{1 + \exp(\frac{-n - mdl}{\alpha})}&lt;/script&gt;, а &lt;script type=&quot;math/tex&quot;&gt;\scriptsize mdl&lt;/script&gt; — минимум среди всех примеров на уровне.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;James-Stein Encoder кодируется по формуле &lt;script type=&quot;math/tex&quot;&gt;x^k = (1 - B) * \frac{n^+ + prior*m}{u^+ + m}&lt;/script&gt; &lt;script type=&quot;math/tex&quot;&gt;+ B*\frac{y^+}{y}&lt;/script&gt;, где &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; дополнительный гиперпараметр, регулирующий переобучение&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;M-estimate кодируется по формуле &lt;script type=&quot;math/tex&quot;&gt;x^k = \frac{n^+}{n} + B * \frac{y^+}{y}&lt;/script&gt;, где &lt;script type=&quot;math/tex&quot;&gt;m = 1... 100&lt;/script&gt; — дополнительный гиперпараметр, регулирующий переобучение. По сути — упрощенный вариант Target Encoder. (На момент написания статьи кодировщик работает некорректно)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Weight of Evidence (WOE) считается по формуле &lt;script type=&quot;math/tex&quot;&gt;x^k = \ln(\frac{nominator}{denominator})&lt;/script&gt;, где &lt;script type=&quot;math/tex&quot;&gt;nominator = \frac{n^+ + \alpha}{y^+ + 2\alpha}&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;denominator = \frac{n - n^+ + \alpha}{y - y^+ + 2\alpha}&lt;/script&gt;. Кодировщик часто используется для подсчета рисков и других скорингов, т.к. по сути производит упорядочивание в логарифмическом масштабе. Хорошо решает проблему стандартизации и группировки разреженных данных. Проблема — теряются данные на биннинге, не учитывается корреляция между зависимыми данными и сам кодировщик легко может переобучиться.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Альтернативой WOE является PRE (Probability Ratio Encoding). В этом случае для каждой метки вычисляется &lt;script type=&quot;math/tex&quot;&gt;P(1)/P(0)&lt;/script&gt;, т.е отношение вероятностей того, что объект размечен положительно и вероятность отрицательной разметки. Этим значением заменяется значение при кодировании. &lt;script type=&quot;math/tex&quot;&gt;P(0)&lt;/script&gt; естественно ни при каких условиях не принимается равным 0. В CE метод не реализован.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Leave One Out (LOO) считается среднее цели для примера выбранной категории, для случая, когда пример удален из дата-сета.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Catboost Encoder улучшенный LOO (&lt;a href=&quot;https://catboost.ai/docs/concepts/algorithm-main-stages_cat-to-numberic.html&quot;&gt;документация&lt;/a&gt;)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;У всех target-based кодировщиков имеет место проблема риска переобучения, так как используются данные о разметке дата-сета. Два варианта решения — дополнительная регуляризация и двойная кросс-валидация. Кроме того LOO и Catboost Encoder работают плохо, если реальные данные имеют другую размерность, что приводит к сдвигу по отноешнию к данным, на которых производилось обучение.&lt;/p&gt;

&lt;h3 id=&quot;остальные-кодировщики&quot;&gt;Остальные кодировщики&lt;/h3&gt;

&lt;p&gt;В CE реализовано несколько базовых кодировщиков:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;One Hot — аналог OnHotEncoder в scikit-learn или get_dummies в pandas&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Ordinal только для упорядоченных признаков (обратите внимание при импорте, что класс в CE называется также, как OrdinalEncoder в scikit-learn)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Binary конвертит категории признака в бинарный код. Категории конвертятся в номера по порядку, затем номера кодируются на двоичной базе, а затем единицы и нули из полученых кодированных значений выносятся в новые признаки. По сути, &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; категорий переводятся в &lt;script type=&quot;math/tex&quot;&gt;log_{2}n&lt;/script&gt; бинаризированных признаков. Это весьма значительно сокращает количество признаков на выходе по сравнению с One Hot и полезно, когда число кодируемых категорий значительно.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Base N комбинирует One Hot и Binary&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Кроме того, реализован Hashing, позволяющий хешировать категории. Это аналог FeatureHasher (последний больше подходит для работы с текстом). Также походит для кодирования большого числа категорий, так как сокращает размерность на выходе по сравнению с One Hot.&lt;/p&gt;

&lt;h3 id=&quot;чего-нет-в-ce&quot;&gt;Чего нет в CE&lt;/h3&gt;

&lt;p&gt;Не реализован Label Encoding. Можно воспользоваться factorize из pandas или LabelEncoder из sklearn или Ordinal, что то же самое. Не реализован Frequincy Encoding, когда категории кодируются в числовом виде в зависимости от частоты для признака в диапазоне [0, 1]. Кроме того, нет методов для кодирования признаков, которые явно упорядочены циклически, например, дат и времени. Ну и, естественно, нет методов для конструирования признаков, таких как разделение выражения на части и т.д. Все это придется написать самостоятельно или искать более специфическое решение.&lt;/p&gt;

&lt;h2 id=&quot;как-использовать-кодирование-категориальных-признаков&quot;&gt;Как использовать кодирование категориальных признаков&lt;/h2&gt;

&lt;p&gt;Есть множество разных рекомендаций. Все их можно свести к следующему:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Определить, относится ли вообще признак к категориальному и посчитать количество категорий.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Необходимо понять природу категориального признака, отнести его к номинальному или упорядоченному типу, установить циклические зависимости для категорий и другие особенности распределения категорий&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Необходимо знать, к какому распределению данных лучше приспособлена обучаемая модель. Это позволит сразу выбрать наиболее оптимальный метод кодирования&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Методы, использующие гиперпараметры, желательно сразу включить в цикл поиска оптимального решения.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Для частично упорядоченных признаков понять, можно ли соотнести категории с численными значениями, расположенными на эквивалентных интервалах. Если да, то стоит подумать о применении Ordinal Encoding. если нет, то можно попробовать один из методов контрастного кодирования. Если же количество категорий велико и есть проблемы с вычислительной сложностью по памяти, можно попробовать один из методов кодирования, сокращающий выходную размерность, например, хеширование. При этом надо помнить, что это может привести к потере данных.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Для неупорядоченных признаков можно использовать One Hot, если число категорий невелико. Большое количество категорий  можно также бинаризировать или хешировать, если потеря части данных приемлема. Если нет, придется использовать один из методов target encoding. Необходимо помнить о переобучении и построить, при необходимости, двойную кросс-валидацию.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;На практике, на мой взгляд, можно миксовать различные методы, попутно расширяя пространство признаков. Например, можно сконструировать новые признаки, применить относительно простые кодировщики к части исходных, а на выходе закодировать весь пул по цели. Пространство для экспериментов ограничено, как всегда, только по вычислительной сложности.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Дополнительные статьи по этой тематике: &lt;a href=&quot;https://towardsdatascience.com/all-about-categorical-variable-encoding-305f3361fd02&quot;&gt;один&lt;/a&gt;, &lt;a href=&quot;https://towardsdatascience.com/benchmarking-categorical-encoders-9c322bd77ee8&quot;&gt;два&lt;/a&gt;&lt;/p&gt;</content><author><name>Klepikov Konstantin</name></author><category term="preprocessing" /><category term="category-encoders" /><category term="sklearn" /><category term="scikit-learn" /><category term="ml-data" /><summary type="html">В статье «особенности препроцессинга данных в scikit-learn» разбирались особенности кодирования признаков с помощью библиотеки scikit-learn. К сожалению, набор инструментов scikit-learn довольно скромный.</summary></entry><entry><title type="html">Вычислительная сложность машинного обучения. Базовые принципы</title><link href="https://konstantinklepikov.github.io/2019/10/19/complexity-basics-terms.html" rel="alternate" type="text/html" title="Вычислительная сложность машинного обучения. Базовые принципы" /><published>2019-10-19T00:00:00+02:00</published><updated>2019-10-19T00:00:00+02:00</updated><id>https://konstantinklepikov.github.io/2019/10/19/complexity-basics-terms</id><content type="html" xml:base="https://konstantinklepikov.github.io/2019/10/19/complexity-basics-terms.html">&lt;p&gt;Чуть ранее, в статье &lt;a href=&quot;/2019/09/08/time-complexity-of-machine-learning-algorithms.html&quot;&gt;временная сложность алгоритмов машинного обучения&lt;/a&gt;, я разбирал временную сложность некоторых алгоритмов из библиотеки scykit-learn. Настало время немного подробнее остановиться на том, как в принципе считается вычислительная сложность data science.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Вычислительная сложность&lt;/strong&gt; (или асимптотическая сложность или производительность) — это свойство алгоритма. Она определяется функцией, которая показывает насколько ухудшается работа алгоритма с усложнением поставленной задачи.&lt;/p&gt;

&lt;p&gt;Вот пять основных правил расчета вычислительной сложности:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;если для математической функции &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; алгоритму необходимо выполнить действия &lt;script type=&quot;math/tex&quot;&gt;f(N)&lt;/script&gt; раз, то для этого ему понадобится сделать &lt;script type=&quot;math/tex&quot;&gt;O(f(N))&lt;/script&gt; шагов.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;если алгоритм выполняет одну операцию, состоящую из &lt;script type=&quot;math/tex&quot;&gt;O(f(N))&lt;/script&gt; шагов, а затем вторую, состоящую из &lt;script type=&quot;math/tex&quot;&gt;O(g(N))&lt;/script&gt; шагов, то общая производительность f и g суммируется &lt;script type=&quot;math/tex&quot;&gt;O(f(N) + g(N))&lt;/script&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;если алгоритму необходимо сделать &lt;script type=&quot;math/tex&quot;&gt;O(f(N) + g(N))&lt;/script&gt; шагов и область значений N функции &lt;script type=&quot;math/tex&quot;&gt;f(N)&lt;/script&gt; больше чем у &lt;script type=&quot;math/tex&quot;&gt;g(N)&lt;/script&gt;, то вычислительную сложность можно упростить до &lt;script type=&quot;math/tex&quot;&gt;f(N)&lt;/script&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;если алгоритму внутри каждого шага &lt;script type=&quot;math/tex&quot;&gt;O(f(N))&lt;/script&gt; одной операции приходится выполнять еще &lt;script type=&quot;math/tex&quot;&gt;O(g(N))&lt;/script&gt; шагов другой операции, то общая производительность составляет &lt;script type=&quot;math/tex&quot;&gt;O(f(N)*g(N))&lt;/script&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;постоянными множителями (константами) можно пренебречь: &lt;script type=&quot;math/tex&quot;&gt;O(C*f(N))&lt;/script&gt; и &lt;script type=&quot;math/tex&quot;&gt;O(f(C*N))&lt;/script&gt; можно записать как &lt;script type=&quot;math/tex&quot;&gt;O(f(N))&lt;/script&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Нотация &lt;strong&gt;«O» большое&lt;/strong&gt; всего лишь указывает на то, что мы рассматриваем ситуацию, когда алгоритму для завершения необходимо потребить  максимальное возможное количество (худший случай). В предыдущей статье рассматривался частный случай, входящий в обобщенное понятие вычислительной сложности — временная сложность алгоритмов МО. Грубо говоря, объем задачи алгоритма всегда связан с вычислительными ресурсами — временем (или количеством шагов) вычислений и пространством (или объемом памяти), необходимыми для завершения задачи. Поэтому в различной специальной литературе по машинному обучению, где рассматриваются частные случаи алгоритмов, можно встретить отсылки как к вычислительной сложности в целом так и к сложности по времени или по памятми.&lt;/p&gt;

&lt;p&gt;На практике чаще всего встречаются следующие сложности:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;O(1)&lt;/script&gt; вне зависимости от сложности задачи время выполнения алгоритма постоянно&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;O(\log(N))&lt;/script&gt; на каждом шаге алгоритма происходит деление количества рассматриваемых элементов на фиксированный коэффициент&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;O(N)&lt;/script&gt; рост числа входов вызывает линейный рост производительности&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;O(N*\log(N))&lt;/script&gt; алгоритм с логарифмической сложностью, на каждом шаге которого производится дополнительная операция с каждым элементом&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;O(N^2)&lt;/script&gt; перебор всех данных, а затем повторный их перебор. Степень может быть другой, что, очевидно, влияет на сложность вычислений.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;O(2^N)&lt;/script&gt; экспоненциальная сложность и &lt;script type=&quot;math/tex&quot;&gt;O(!N)&lt;/script&gt; факториальная сложность&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Задачи со сложностью до &lt;script type=&quot;math/tex&quot;&gt;O(N*\log(N))&lt;/script&gt; включительно решаемы. При грамотном управлении количеством входных данных решаемы и задачи со степенной сложностью. Экспоненциальные и факториальные сложности, в виду в целом большого входного объема данных, в МО неприменимы.&lt;/p&gt;

&lt;p&gt;Ключевым вопросом в оценке сложности алгоритмов МО является их класс, определяющий требования ко времени и ресурсам памяти, применительно к некой абстрактной машине (часто рассматривается детерминированная машина, в частности, машина Тьюринга). Для детерминированных машин определены следующие классы:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;DTIME(f(N))&lt;/script&gt; задачи, которые машина решает за время &lt;script type=&quot;math/tex&quot;&gt;f(N)&lt;/script&gt;. Временная сложность таким образом будет составлять &lt;script type=&quot;math/tex&quot;&gt;O(f(N))&lt;/script&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;P&lt;/script&gt; задачи, с которыми машина справляется за полиномиальное время&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;EXPTIME(EXP)&lt;/script&gt; задачи, с которыми машина справляется за экспоненциальное время&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Для недетерминированных машин:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;NTIME(f(N))&lt;/script&gt; задачи, которые машина решает за время &lt;script type=&quot;math/tex&quot;&gt;f(N)&lt;/script&gt;. Временная сложность, таким образом будет, составлять &lt;script type=&quot;math/tex&quot;&gt;O(f(N))&lt;/script&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;NP&lt;/script&gt; задачи, с которыми машина справляется за полиномиальное время&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;NEXPTIME(EXP)&lt;/script&gt; задачи, с которыми машина справляется за экспоненциальное время&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Аналогичным образом задачи делятся в зависимости от потребляемого объема памяти.&lt;/p&gt;

&lt;p&gt;Не вдаваясь в подроности, в общем случае &lt;script type=&quot;math/tex&quot;&gt;P \subseteq NP&lt;/script&gt;, экспоненциальные задачи, по сути, не считаемые, а задачей построения алгоритмов МО, в том числе, является их сведение к менее затратному классу. Задачи, которые входят в класс NP и к которым можно свести любые другие задачи этого класса за полиномиальное время называются NP-полными. NP-сложные задачи необязательно относятся к классу NP.&lt;/p&gt;

&lt;h2 id=&quot;время-обучения-для-алгоритмов-мо&quot;&gt;Время обучения для алгоритмов МО&lt;/h2&gt;

&lt;p&gt;Фактическое время работы алгоритма МО зависит от конкретной машины, на которой алгоритм реализован. В общем случае алгоритм обучения с учителем имеет доступ к множеству примеров, классу гипотез, функции потерь и обучающему набору, взятому из множества примеров. Четкого понятия размера входных данных для такого алгоритма не существует, т.к. если мы предъявляем алгоритму избыточное количество обучающих примеров, он может игнорировать лишние. Поэтому увеличение размера обучающего набора не ведет к тому, что проблема обучения становится более трудной. кроме того, алгоритм обучения может передавать часть вычислений выходной гипотезе, в случае, когда такая гипотеза определена как функция, сохраняющая обучающий набор. Для этого вводятся понятия времени обучения и времени предсказания. Будем рассматривать алгоритмы, чье время предсказания не превышает время обучения.&lt;/p&gt;

&lt;p&gt;Вычислительная сложность алгоритма обучения определяется в два этапа:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;дана функция &lt;script type=&quot;math/tex&quot;&gt;f : (0, 1)^2 \rightarrow \mathbb{N}&lt;/script&gt;, задача обучения &lt;script type=&quot;math/tex&quot;&gt;(Z, H, l)&lt;/script&gt; и алгоритм обучения &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;. Алгоритм &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; решает задачу обучения за время &lt;script type=&quot;math/tex&quot;&gt;O(f)&lt;/script&gt;, если существует постоянное число &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; такое, что для любого распределения вероятности &lt;script type=&quot;math/tex&quot;&gt;D&lt;/script&gt; на &lt;script type=&quot;math/tex&quot;&gt;Z&lt;/script&gt; и входных параметров &lt;script type=&quot;math/tex&quot;&gt;\epsilon, \delta \in (0, 1)&lt;/script&gt; справедливо следующее утверждение: если &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; имеет доступ к примерам, независимо выбранным из распределения &lt;script type=&quot;math/tex&quot;&gt;D&lt;/script&gt;, то, во-первых, &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; завершается, выполнив не более &lt;script type=&quot;math/tex&quot;&gt;c f(\epsilon, \delta)&lt;/script&gt; операций, во-вторых, выход &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; обозначаемый как &lt;script type=&quot;math/tex&quot;&gt;h{\scriptstyle A}&lt;/script&gt; можно применять для предсказания метки нового примера и при этом будет выполнено не более &lt;script type=&quot;math/tex&quot;&gt;c f(\epsilon, \delta)&lt;/script&gt; операций и, в-третьих, выход &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; вероятно почти корректен, т.е. с вероятностью не ниже &lt;script type=&quot;math/tex&quot;&gt;1 - \delta&lt;/script&gt; (для случайной выборки, которую получает &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;) &lt;script type=&quot;math/tex&quot;&gt;{L_{\scriptscriptstyle D}}({h_{\scriptscriptstyle A}}) \leq {\min_{\scriptscriptstyle h'\in H}} {L_{\scriptscriptstyle D}}{(h'_{\scriptscriptstyle A}}) + \epsilon&lt;/script&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;далее, рассматриваем последовательность проблем обучения &lt;script type=&quot;math/tex&quot;&gt;{({Z_{\scriptscriptstyle n}}, {H_{\scriptscriptstyle n}}, {l_{\scriptscriptstyle n}})^{\scriptscriptstyle{\infty}}_{\scriptscriptstyle n=1}}&lt;/script&gt;, где проблема &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; описывается областью примеров &lt;script type=&quot;math/tex&quot;&gt;{Z_{\scriptscriptstyle n}}&lt;/script&gt;, классом гипотез &lt;script type=&quot;math/tex&quot;&gt;{H_{\scriptscriptstyle n}}&lt;/script&gt; и функцией потерь &lt;script type=&quot;math/tex&quot;&gt;{l_{\scriptscriptstyle n}}&lt;/script&gt;. Если &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; спроектирован для проблем обучения такого вида и задана функция &lt;script type=&quot;math/tex&quot;&gt;g : \mathbb{N} x (0, 1)^2 \rightarrow \mathbb{N}&lt;/script&gt;, то считается, что время работы &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; на вышеупомянутой последовательности равно &lt;script type=&quot;math/tex&quot;&gt;O(g)&lt;/script&gt;, если для всех &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; решает проблему &lt;script type=&quot;math/tex&quot;&gt;({Z_{\scriptscriptstyle n}}, {H_{\scriptscriptstyle n}}, {l_{\scriptscriptstyle n}})&lt;/script&gt; за время  &lt;script type=&quot;math/tex&quot;&gt;O({f_{\scriptscriptstyle n}})&lt;/script&gt;, где функция &lt;script type=&quot;math/tex&quot;&gt;f : (0, 1)^2 \rightarrow \mathbb{N}&lt;/script&gt; определяется выражением &lt;script type=&quot;math/tex&quot;&gt;{f_{\scriptscriptstyle n}}(\epsilon, \delta) = {g_{\scriptscriptstyle n}}(n, \epsilon, \delta)&lt;/script&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;В таком случае можно сказать, что алгоритм &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; эффективен на последовательности &lt;script type=&quot;math/tex&quot;&gt;({Z_{\scriptscriptstyle n}}, {H_{\scriptscriptstyle n}}, {l_{\scriptscriptstyle n}})&lt;/script&gt;, если его время работы равно &lt;script type=&quot;math/tex&quot;&gt;O(p(n, 1/\epsilon, 1/\delta))&lt;/script&gt; для некоторого полинома p. Очевидно, что вопрос об эффективном решении проблемы обучения зависит от того, как именно задача обучения представлена в виде последовательности конкретных проблем.&lt;/p&gt;

&lt;p&gt;Более подробную информацию на эту тему можно найти в учебнике «Understanding Machine Learning», изданном в Cambridge University Press в 2014-ом году.&lt;/p&gt;</content><author><name>Klepikov Konstantin</name></author><category term="machine-learning" /><category term="algorithms" /><category term="time-complexity" /><summary type="html">Чуть ранее, в статье временная сложность алгоритмов машинного обучения, я разбирал временную сложность некоторых алгоритмов из библиотеки scykit-learn. Настало время немного подробнее остановиться на том, как в принципе считается вычислительная сложность data science.</summary></entry><entry><title type="html">Особенности препроцессинга данных в scikit-learn</title><link href="https://konstantinklepikov.github.io/2019/10/08/scikit-learn-preprocessing.html" rel="alternate" type="text/html" title="Особенности препроцессинга данных в scikit-learn" /><published>2019-10-08T00:00:00+02:00</published><updated>2019-10-08T00:00:00+02:00</updated><id>https://konstantinklepikov.github.io/2019/10/08/scikit-learn-preprocessing</id><content type="html" xml:base="https://konstantinklepikov.github.io/2019/10/08/scikit-learn-preprocessing.html">&lt;p&gt;В статье кратко раскрываются некоторые вопросы подготовки данных с помощью scikit-learn.&lt;/p&gt;

&lt;h3 id=&quot;замена-пропусков&quot;&gt;Замена пропусков&lt;/h3&gt;

&lt;p&gt;Scikit-learn не поддерживает замену пропусков с разными значениями. Сначала придется последовательно перегнать все интересующие пропуски, к примеру, в &lt;em&gt;NaN&lt;/em&gt;, а затем использовать инструменты препроцессинга.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.impute.MissingIndicator.html&quot;&gt;MissingIndicator&lt;/a&gt; позволяет сделать разметку пропусков. С помощью &lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.impute.SimpleImputer.html&quot;&gt;SimpleImputer&lt;/a&gt; можно выполнить замену. Поддерживаются четыре основных метода:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;mean&lt;/li&gt;
  &lt;li&gt;most_frequent&lt;/li&gt;
  &lt;li&gt;median&lt;/li&gt;
  &lt;li&gt;constant (необходимо задать fill_value, чтобы не получить дефолтное значение)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Препроцессинг перегоняет данные в Numpy-формат, что означает потерю метаданных. Если это представляет проблему - препроцессинг делать средствами Pandas.&lt;/p&gt;

&lt;p&gt;Есть еще несколько популярных методов, например, кластеризация с использованием K ближайших соседей и интерполяция. Оба метода не поставляются в scikit-learn. придется поискать реализации поверх.&lt;/p&gt;

&lt;h3 id=&quot;полиномиальные-признаки&quot;&gt;Полиномиальные признаки&lt;/h3&gt;

&lt;p&gt;Перед работой с &lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.PolynomialFeatures.html&quot;&gt;PolynomialFeatures&lt;/a&gt; надо иметь представление о том, как будут обрабатываться пропуски, так как NaN поднимет ошибку, а 0 для полиномов всех степеней останется нулем.&lt;/p&gt;

&lt;p&gt;Есть возможность создавать матрицу без степенных вариаций (для этого необходимо задать interaction_only=True).&lt;/p&gt;

&lt;p&gt;Весь процесс очень затратен по оперативной памяти и на нем довольно легко столкнуться нехваткой, поэтому, если дата-сет большой, придется предварительно подумать как с ним работать.&lt;/p&gt;

&lt;h3 id=&quot;категориальные-признаки&quot;&gt;Категориальные признаки&lt;/h3&gt;

&lt;p&gt;Scikit-learn не поддерживает обработку категориальных признаков, только замену на численное представление. Вариантов два:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OrdinalEncoder.html&quot;&gt;OrdinalEncoder&lt;/a&gt; для численного представления без разделения на отдельные признаки (пропуски тоже кодируются в собственный отдельный класс)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html&quot;&gt;OneHotEncoder&lt;/a&gt; для численного представления с разделением на отдельные признаки с бинарными классами для каждого признака.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;обработка-численных-признаков&quot;&gt;Обработка численных признаков&lt;/h3&gt;

&lt;p&gt;Численные признаки могут можно дискретизировать с помощью scikit-learn и, таким образом, перегонять их в категориальные. Поддерживаются два основных способа:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;discretisation (или квантилизация или биннинг). Доступно в виде &lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.KBinsDiscretizer.html&quot;&gt;KBinsDiscretizer&lt;/a&gt; с тремя методами: uniform (одинаковая длина бинов), quantile (одинаковое число точек в бинах), kmeans (значение определяется кластеризацией).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;binarisation с помощью &lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.binarize.html&quot;&gt;binarize&lt;/a&gt; — задается trashold, все что ниже или рано 0, все что выше 1.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;препроцессинг&quot;&gt;Препроцессинг&lt;/h2&gt;

&lt;p&gt;Собственно непосредственно сам препроцессинг описан в &lt;a href=&quot;https://scikit-learn.org/stable/modules/preprocessing.html&quot;&gt;разделе Preprocessing data&lt;/a&gt;. В scikit-learn это трансформация и нормализация данных. Делать это необходимо, так как многие алгоритмы чувствительны к выбросам, а так же распределению данных в выборке.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html&quot;&gt;StandardScaler&lt;/a&gt; центрирует данные, удаляет среднее значение для каждого объекта, а затем масштабирует, деля на среднее отклонение. &lt;script type=&quot;math/tex&quot;&gt;x{\scriptstyle scaled} = \frac{x - u}{s}&lt;/script&gt;, где &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; среднее, а &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; отклонение.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMaxScaler.html&quot;&gt;MinMaxScaler&lt;/a&gt; трансформирует признаки в выбранном диапазоне. &lt;script type=&quot;math/tex&quot;&gt;x{\scriptstyle scaled} = \frac{x - \min(x)}{\max(x) - \min(x)}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MaxAbsScaler.html&quot;&gt;MaxAbsScaler&lt;/a&gt; трансформирует в диапазон &lt;script type=&quot;math/tex&quot;&gt;[-1, 1]&lt;/script&gt;. Используется для центрированных вокруг нуля или разреженных данных. &lt;script type=&quot;math/tex&quot;&gt;x{\scriptstyle scaled} = \frac{x}{\max(abs(x))}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.RobustScaler.html&quot;&gt;RobustScaler&lt;/a&gt;. Для данных, в которых много выбросов.&lt;/p&gt;

&lt;p&gt;Для нормализации данных можно использовать &lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.Normalizer.html&quot;&gt;Normalizer&lt;/a&gt;. Довольно часто это становится необходимым, когда алгоритм предсказывает, базируясь на взвешенных значениях, основанных на расстояниях между точками данных. Особенно актуально для классификации текста и кластеризации. В scikit-learn доступны три регуляризатора:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;l1&lt;/li&gt;
  &lt;li&gt;l2&lt;/li&gt;
  &lt;li&gt;MaxAbsScaler&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Klepikov Konstantin</name></author><category term="machine-learning" /><category term="scikit-learn" /><category term="ml-data" /><category term="preprocessing" /><summary type="html">В статье кратко раскрываются некоторые вопросы подготовки данных с помощью scikit-learn.</summary></entry><entry><title type="html">Зависимость вычислений в scikit-learn от данных и модели</title><link href="https://konstantinklepikov.github.io/2019/09/28/computation-performance-of-scikit-learn-functions.html" rel="alternate" type="text/html" title="Зависимость вычислений в scikit-learn от данных и модели" /><published>2019-09-28T00:00:00+02:00</published><updated>2019-09-28T00:00:00+02:00</updated><id>https://konstantinklepikov.github.io/2019/09/28/computation-performance-of-scikit-learn-functions</id><content type="html" xml:base="https://konstantinklepikov.github.io/2019/09/28/computation-performance-of-scikit-learn-functions.html">&lt;h2 id=&quot;производительность-вычислений&quot;&gt;Производительность вычислений&lt;/h2&gt;

&lt;p&gt;В scikit-learn производительность вычисления предсказаний зависит от:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;количества фичей&lt;/li&gt;
  &lt;li&gt;распределения и разреженности данных&lt;/li&gt;
  &lt;li&gt;временной сложности алгоритма&lt;/li&gt;
  &lt;li&gt;извлечения фичей&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;количество-фичей&quot;&gt;Количество фичей&lt;/h3&gt;

&lt;p&gt;Библиотека хорошо оптимизирована под небольшие дата-сеты, поэтому количество фичей начинает оказывать значительное влияние на время предсказания для данных с 250+ фичами.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../assets/img/280919-01.jpg&quot; alt=&quot;Влияние количества фичей на время предсказания&quot; title=&quot;Влияние количества фичей на время предсказания&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;распределение-и-разреженность-данных&quot;&gt;Распределение и разреженность данных&lt;/h3&gt;

&lt;p&gt;Вычисления по разреженным дата-сетам (более 90% значений) можно улучшить по времени с помощью ScyPy, т.к. библиотека оптимизирована по потреблению кеша CPU. Подробнее о том, как готовить разреженные данные, можно посмотреть в &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/sparse.html&quot;&gt;документации ScyPy&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;временная-сложность-алгоритмов&quot;&gt;Временная сложность алгоритмов&lt;/h3&gt;

&lt;p&gt;С ростом временной сложности падает производительность вычислений алгоритма на предсказаниях. В примерах - зависимость задержки вычисления предсказания от временной сложности линейных моделей, SVM и ансамблей.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../assets/img/280919-02.jpg&quot; alt=&quot;Зависимость задержки вычислений предсказаний от временной сложности для линейных моделей&quot; title=&quot;Зависимость от временной сложности для линейных моделей&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../assets/img/280919-03.jpg&quot; alt=&quot;Зависимость задержки вычислений предсказаний от временной сложности для SVM&quot; title=&quot;Зависимость от временной сложности для SVM&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../assets/img/280919-04.jpg&quot; alt=&quot;Зависимость задержки вычислений предсказаний от временной сложности для ансамблей&quot; title=&quot;Зависимость от временной сложности для ансамблей&quot; /&gt;&lt;/p&gt;

&lt;p&gt;В линейных моделях используется схожая решающая функция, поэтому время предсказаний для разных линейных моделей зависит примерно одинаково от временной сложности модели. В алгоритмах с нелинейными кернелами вычислительная производительность зависит от количества векторов (чем больше, тем производительность меньше). Задержка вычисления предсказания возрастает линейно для SVM (для регрессора и классификатора) с ростом числа саппортных векторов. Для ансамблей наибольшее значение имеет количество решающих деревьев и их глубина.&lt;/p&gt;

&lt;p&gt;Про временную сложность построения алгоритмов и подробнее про сложность расчета предсказаний можно почитать в &lt;a href=&quot;/2019/09/08/time-complexity-of-machine-learning-algorithms.html&quot;&gt;отдельной статье&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;извлечение-фичей&quot;&gt;Извлечение фичей&lt;/h3&gt;

&lt;p&gt;На самом деле, препроцессинг данных занимает самую значительную часть времени в выдаче предсказаний. Часто очистка и трансформация данных может увеличивать задержку выдачи предсказаний в сотни раз, поэтому этот процесс необходимо постоянно внимательно и аккуратно улучшать.&lt;/p&gt;

&lt;h2 id=&quot;пропускная-способность-предсказаний&quot;&gt;Пропускная способность предсказаний&lt;/h2&gt;

&lt;p&gt;Еще одна важная метрика производительности алгоритма - это пропускная способность, определяющая количество предсказаний за заданное время. В примере пропускная способность различных алгоритмов scikit-learn.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../assets/img/280919-05.jpg&quot; alt=&quot;Пропускная способность различных алгоритмов scikit-learn&quot; title=&quot;Пропускная способность различных алгоритмов scikit-learn&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Основной способ повышения пропускной способности предсказывающей модели - это увеличение количества экземпляров модели и распределение запросов на предсказания между экземплярами.&lt;/p&gt;

&lt;p&gt;Больше информации и примеров про производительность вычислений scikit-learn можно прочитать в &lt;a href=&quot;https://scikit-learn.org/stable/documentation.html&quot;&gt;технической документации&lt;/a&gt; (смотрите &lt;a href=&quot;https://scikit-learn.org/stable/modules/computing.html&quot;&gt;раздел 7&lt;/a&gt; user guide).&lt;/p&gt;</content><author><name>Klepikov Konstantin</name></author><category term="machine-learning" /><category term="algorithms" /><category term="time-complexity" /><category term="scikit-learn" /><category term="ml-data" /><category term="computation-performance" /><summary type="html">Производительность вычислений</summary></entry><entry><title type="html">Основные термины машинного обучения. Часть №2</title><link href="https://konstantinklepikov.github.io/2019/09/14/machine_learning-terms-part-two.html" rel="alternate" type="text/html" title="Основные термины машинного обучения. Часть №2" /><published>2019-09-14T00:00:00+02:00</published><updated>2019-09-14T00:00:00+02:00</updated><id>https://konstantinklepikov.github.io/2019/09/14/machine_learning-terms-part-two</id><content type="html" xml:base="https://konstantinklepikov.github.io/2019/09/14/machine_learning-terms-part-two.html">&lt;p&gt;В &lt;a href=&quot;/2019/08/31/machine_learning-terms.html&quot;&gt;первой части&lt;/a&gt; статьи я разобрал базовую терминологию ML: постановку задачи, емкость, переобучение и недообучение, регуляризацию и гиперпараметры, точечную оценку, смещение оценки, дисперсию, стандартную ошибку и состоятельность, а так-же важные термины, определяемые в рамках этих терминов. Продолжим.&lt;/p&gt;

&lt;h2 id=&quot;оценка-максимального-правдоподобия&quot;&gt;Оценка максимального правдоподобия&lt;/h2&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\theta{\tiny ML} = \underset{\theta}{\arg\max}\ p{\tiny model}(\mathbb{X};\theta) =&lt;/script&gt; &lt;script type=&quot;math/tex&quot;&gt;\underset{\theta}{\arg\max}\ \underset{i=1}{\overset{m}{\prod}}\ p{\tiny model}(\mathbf{x}^{(i)};\theta)&lt;/script&gt;, где:&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\mathbb{X} = \{ x^{(1)}, ... x^{(m)} \}&lt;/script&gt; — множество, состоящее из &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; примеров, независимо выбираемых из неизвестного порождающего распределения &lt;script type=&quot;math/tex&quot;&gt;p{\tiny data}(\mathbf{x})&lt;/script&gt;. В выражении максимального правдоподобия &lt;script type=&quot;math/tex&quot;&gt;p{\tiny model}(\mathbf{x};\theta)&lt;/script&gt; — параметрическое семейство распределений вероятности над  одним и тем же пространством, индексированное параметром &lt;script type=&quot;math/tex&quot;&gt;\theta&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Произведение неудобно по причине, т.к. подвержено потере значимости. Взятие логарифма не изменяет &lt;script type=&quot;math/tex&quot;&gt;\arg\max&lt;/script&gt;, но позволяет преобразовать произведение в сумму: &lt;script type=&quot;math/tex&quot;&gt;\theta{\tiny ML} = \underset{\theta}{\arg\max}\ \underset{i=1}{\overset{m}{\sum}}\ \log\ p{\tiny model}(\mathbf{x}^{(i)};\theta)&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Если разделить правую часть на &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; (умножение функции стоимости на константу не изменяет &lt;script type=&quot;math/tex&quot;&gt;\arg\max&lt;/script&gt;), мы получаем математическое ожидание относительного эмпирического распределения &lt;script type=&quot;math/tex&quot;&gt;\hat{p}{\tiny data}&lt;/script&gt; определяемого обучающими данными: &lt;script type=&quot;math/tex&quot;&gt;\theta{\tiny ML} = \underset{\theta}{\arg\max}\ \mathbb{E}{\scriptsize x-\hat{p}{\tiny data}}\ \log\ p{\tiny model}(\mathbf{x};\theta)&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Максимальное правдоподобие — это попытка совместить модельное распределение с эмпирическим &lt;script type=&quot;math/tex&quot;&gt;\hat{p}{\tiny data}&lt;/script&gt;, в идеале мы хотим получить совпадение истинного и порождающего распределения &lt;script type=&quot;math/tex&quot;&gt;p{\tiny data}&lt;/script&gt;. Это интерпретируется с помощью минимизации расхождения Кульбака-Лейблера.&lt;/p&gt;

&lt;h3 id=&quot;условное-логарифмическое-правдоподобие&quot;&gt;Условное логарифмическое правдоподобие&lt;/h3&gt;

&lt;p&gt;Если &lt;script type=&quot;math/tex&quot;&gt;\mathbf{X}&lt;/script&gt; представляет все входы, &lt;script type=&quot;math/tex&quot;&gt;\mathbf{Y}&lt;/script&gt; все наблюдаемые выходы, а все примеры независимы и одинаково распределены, то условное логарифмическое правдоподобие: &lt;script type=&quot;math/tex&quot;&gt;\theta{\tiny ML} = \underset{\theta}{\arg\max}\ \underset{i=1}{\overset{m}{\sum}}\ \log\ P(\mathbf{y}^{(i)}\mid\mathbf{x}^{(i)};\theta)&lt;/script&gt;&lt;/p&gt;

&lt;h2 id=&quot;байесовская-статистика&quot;&gt;Байесовская статистика&lt;/h2&gt;

&lt;p&gt;В отличие от частотного метода, в котором предполагается, что истинное значение &lt;script type=&quot;math/tex&quot;&gt;\theta&lt;/script&gt; фиксировано хотя и неизвестно, а точечная оценка &lt;script type=&quot;math/tex&quot;&gt;\hat{\theta}&lt;/script&gt; — случайная величина, в байесовском подходе к статистике истинный параметр &lt;script type=&quot;math/tex&quot;&gt;\theta&lt;/script&gt; неизвестен или недостоверен и представляется случайной величиной, а набор данных случайной величиной не является, т.к. доступен прямому наблюдению. До наблюдения данных  мы представляем свое знание о &lt;script type=&quot;math/tex&quot;&gt;\theta&lt;/script&gt; в качестве априорного распределения вероятности &lt;script type=&quot;math/tex&quot;&gt;p(\theta)&lt;/script&gt;. Тогда можно реконструировать влияние данных на наши гипотезы о &lt;script type=&quot;math/tex&quot;&gt;\theta&lt;/script&gt;, объединив правдоподобие данных с априорным посредством теоремы Байеса:&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;p(\theta\mid x^{(1)}, ... x^{(m)}) =&lt;/script&gt; &lt;script type=&quot;math/tex&quot;&gt;\frac{p(x^{(1)}, ... x^{(m)}\mid\theta)p(\theta)}{p(x^{(1)}, ... x^{(m)})}&lt;/script&gt;, где &lt;script type=&quot;math/tex&quot;&gt;x^{(1)}, ... x^{(m)}&lt;/script&gt; — набор наблюдаемых примеров.&lt;/p&gt;

&lt;p&gt;В отличие от оценки максимального правдоподобия, где предсказания делаются с использованием точечной оценки &lt;script type=&quot;math/tex&quot;&gt;\theta&lt;/script&gt;, в байесовской оценке  предсказания делаются с помощью полного распределения &lt;script type=&quot;math/tex&quot;&gt;\theta&lt;/script&gt;. к примеру, после наблюдения &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; примеров предсказанное распределение следующего &lt;script type=&quot;math/tex&quot;&gt;x^{m+1}&lt;/script&gt; примера описывается формулой: &lt;script type=&quot;math/tex&quot;&gt;p(x^{m+1}\mid x^{(1)}, ... x^{(m)}) =&lt;/script&gt; &lt;script type=&quot;math/tex&quot;&gt;\int p(x^{m+1}\mid\theta)p(\theta\mid x^{(1)}, ... x^{(m)})d\theta&lt;/script&gt;. Если после наблюдения &lt;script type=&quot;math/tex&quot;&gt;x^{(1)}, ... x^{(m)}&lt;/script&gt; примеров мы все еще не знаем &lt;script type=&quot;math/tex&quot;&gt;\theta&lt;/script&gt;, то эта неопределенность включается непосредственно в предсказания.&lt;/p&gt;

&lt;p&gt;Кроме того, при байесовской оценке происходит сдвиг плотности вероятности в сторону тех областей пространства параметров, которые априори предпочтительны, что обусловлено значительным влиянием байесовского априорного распределения. Зачастую это приводит к предпочтению более простых и гладких моделей.&lt;/p&gt;

&lt;p&gt;Байесовские модели обобщаются лучше при ограниченном числе обучающих данных, но с ростом данных обучение становится вычислительно более накладным.&lt;/p&gt;

&lt;h3 id=&quot;оценка-априорного-максимума&quot;&gt;Оценка априорного максимума&lt;/h3&gt;

&lt;p&gt;В большинстве случаев операции, включающие апостериорное байесовское распределение, недопустимы с точки зрения временной сложности алгоритмов. В этом случае точечная оценка &lt;script type=&quot;math/tex&quot;&gt;\theta&lt;/script&gt; дает разрешимую апроксимацию. Чтобы использовать преимущества байесовской оценки, разрешив априорному распределению влиять на выбор точечной оценки, применяют оценку апостериорного максимум (MAP):&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\theta{\tiny MAP} = \underset{\theta}{\arg\max}\ p(\theta\mid\mathbf{x})\ =&lt;/script&gt; &lt;script type=&quot;math/tex&quot;&gt;\underset{\theta}{\arg\max}\ \log\ p(\theta\mid\mathbf{x})&lt;/script&gt; &lt;script type=&quot;math/tex&quot;&gt;+ \log\ p(\theta)&lt;/script&gt;, где &lt;script type=&quot;math/tex&quot;&gt;\log\ p(\theta\mid\mathbf{x})&lt;/script&gt; — стандартное логарифмическое правдоподобие, а &lt;script type=&quot;math/tex&quot;&gt;\log\ p(\theta)&lt;/script&gt; соответствует априорному распределению.&lt;/p&gt;

&lt;h2 id=&quot;проблемы-требующие-глубокого-изучения&quot;&gt;Проблемы, требующие глубокого изучения&lt;/h2&gt;

&lt;h3 id=&quot;проклятие-размерности&quot;&gt;Проклятие размерности&lt;/h3&gt;

&lt;p&gt;С увеличением размерности данных количество представляющих интерес конфигураций растет экспоненциально. Если имеется &lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt; измерений и нужно различать &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; значений вдоль каждой оси, то потребуется &lt;script type=&quot;math/tex&quot;&gt;O(v^{d})&lt;/script&gt; областей и примеров.&lt;/p&gt;

&lt;h3 id=&quot;регуляризация-для-достижения-локального-постоянства-и-гладкости&quot;&gt;Регуляризация для достижения локального постоянства и гладкости&lt;/h3&gt;

&lt;p&gt;Чтобы алгоритм хорошо обобщался, необходимо иметь априорное представление о том, какого рода функцию он должен обучить. Самое распространенные априорные предположения — &lt;strong&gt;априорное предположение о гладкости&lt;/strong&gt; или &lt;strong&gt;априорное предположение о локальном постоянстве&lt;/strong&gt;. Это означает, что обучаемая функция не должна сильно изменяться в небольшой области.&lt;/p&gt;

&lt;p&gt;Обобщаемость большинства алгоритмов опирается на этот принцип, поэтому они плохо масштабируются на многие статистические задачи.&lt;/p&gt;

&lt;h3 id=&quot;обучение-многообразий&quot;&gt;Обучение многообразий&lt;/h3&gt;

&lt;p&gt;В основе ML лежит концепция &lt;strong&gt;многообразия&lt;/strong&gt; — множества точек, ассоциированных с окрестностью каждой точки. Из этой концепции вытекает существование преобразований для перемещения из одного места многообразия в другое.&lt;/p&gt;

&lt;p&gt;В ML многообразие — это связное множество точек в пространстве высокой размерности, которое можно хорошо аппроксимировать, вводя в рассмотрение лишь небольшое число степеней свободы, или измерений. В машинном обучении допускаются многообразия, размерность которых различна в разных точках.&lt;/p&gt;

&lt;p&gt;Многие алгоритмы ML безнадежны, если ожидается, что в результате обучения алгоритм должен найти функции с нетривиальными изменениями во всем пространстве &lt;script type=&quot;math/tex&quot;&gt;\mathbb{R}^{n}&lt;/script&gt;. Алгоритмы обучения многообразий преодолевают это препятствие, предполагая, что большая часть &lt;script type=&quot;math/tex&quot;&gt;\mathbb{R}^{n}&lt;/script&gt; — недопустимые входные данные, а интересующие нас входы сосредоточены только в наборе многообразий, содержащем небольшое подмножество точек, причем интересные изменения результирующей функции будут происходить только вдоль направлений, принадлежащих какому-то одному многообразию, или при переходе с одного многообразия на другое.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Данное краткое описание составлено на основе книги «Глубокое обучение» за авторством Я.Гудфеллоу, И.Бенджио, А.Курвилль&lt;/strong&gt;&lt;/p&gt;</content><author><name>Klepikov Konstantin</name></author><category term="machine-learning" /><summary type="html">В первой части статьи я разобрал базовую терминологию ML: постановку задачи, емкость, переобучение и недообучение, регуляризацию и гиперпараметры, точечную оценку, смещение оценки, дисперсию, стандартную ошибку и состоятельность, а так-же важные термины, определяемые в рамках этих терминов. Продолжим.</summary></entry></feed>