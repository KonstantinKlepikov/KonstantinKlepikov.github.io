<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ru_RU"><generator uri="https://jekyllrb.com/" version="3.8.7">Jekyll</generator><link href="https://konstantinklepikov.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://konstantinklepikov.github.io/" rel="alternate" type="text/html" hreflang="ru_RU" /><updated>2021-06-11T02:12:55+02:00</updated><id>https://konstantinklepikov.github.io/feed.xml</id><title type="html">My deep learning</title><subtitle>Блог про нейронные сети и машинное обучение</subtitle><author><name>Klepikov Konstantin</name></author><entry><title type="html">Несколько трюков с переменными в python</title><link href="https://konstantinklepikov.github.io/2021/06/11/some-python-variable-tricks.html" rel="alternate" type="text/html" title="Несколько трюков с переменными в python" /><published>2021-06-11T00:00:00+02:00</published><updated>2021-06-11T00:00:00+02:00</updated><id>https://konstantinklepikov.github.io/2021/06/11/some-python-variable-tricks</id><content type="html" xml:base="https://konstantinklepikov.github.io/2021/06/11/some-python-variable-tricks.html">&lt;p&gt;&lt;img src=&quot;../../../assets/img/110621-01.png&quot; alt=&quot;Несколько трюков с переменными в python&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Иногда, особенно при прототипировании или сборке каких-то нестандартных шаблонов, могут возникнуть специфические задачи, такие как конвертирование строк в имена переменных, конвертирование переменных в значения ключей и т.д. В этой статье я разберу эти задачи и их решения.&lt;/p&gt;

&lt;h2 id=&quot;как-конвертировать-переменные-python-в-ключи-словаря&quot;&gt;Как конвертировать переменные python в ключи словаря&lt;/h2&gt;

&lt;p&gt;Задача выглядит так: надо собрать значения ключей словаря из названий переменных, а значения словаря - из их объектов.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;bird&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fish&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'f'&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;dict_of_animals&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# some code
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dict_of_animals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'bird'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'fish'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'f'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Проблема эта была поднята на &lt;a href=&quot;https://stackoverflow.com/questions/3972872/python-variables-as-keys-to-dict&quot;&gt;stack overflow&lt;/a&gt;. Мне понравилось такое решение:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;dict_of_animals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;locals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'__'&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'dict_of_animals'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Дело в том, что далеко не всегда у вас есть список переменных или желание его составлять, а в данном контексте мы просто смотрим в &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;locals()&lt;/code&gt; и забираем все, что нам нужно.&lt;/p&gt;

&lt;h2 id=&quot;как-конвертировать-строки-в-названия-переменных&quot;&gt;Как конвертировать строки в названия переменных&lt;/h2&gt;

&lt;h3 id=&quot;вариант-1---globals&quot;&gt;Вариант №1 - globals()&lt;/h3&gt;

&lt;p&gt;Функция &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;globals()&lt;/code&gt; в python возвращает словарь текущей глобальной таблицы символов. В глобальной таблице символов хранится вся информация, относящаяся к глобальной области видимости.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;user_input&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;apple&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;globals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user_input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;apple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;вариант-2-locals-аналогично&quot;&gt;Вариант №2 locals() аналогично&lt;/h3&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;user_input&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;apple&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;locals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user_input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;apple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3-exec&quot;&gt;№3 exec()&lt;/h3&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'my_brilliant_name'&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s = %d&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Ilona'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;my_brilliant_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Ilona'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;как-конвертировать-ключи-словаря-в-переменные-python&quot;&gt;Как конвертировать ключи словаря в переменные python&lt;/h2&gt;

&lt;p&gt;Скорее всего, вам придется решить и обратную задачу - импортировать словарь в другое пространство имен и перегнать ключи словаря в названия переменных, а значения - в объекты, на которые ссылаются переменные. Проблема разбирается &lt;a href=&quot;https://stackoverflow.com/questions/18090672/convert-dictionary-entries-into-variables-python&quot;&gt;здесь&lt;/a&gt;. Решение просто как веник:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;dict_of_animals&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'bird'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'fish'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'f'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;locals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dict_of_animals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bird&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Прелесть в том, что вы можете импортировать сразу несколько разных словарей содержащих одинаковые ключи и не заботиться особо о поименовании переменных - значение будет иметь только порядок апдейта.&lt;/p&gt;

&lt;h2 id=&quot;как-импортировать-модуль-название-которого-определяется-при-импорте&quot;&gt;Как импортировать модуль, название которого определяется при импорте&lt;/h2&gt;

&lt;p&gt;Нетривиальная задача, которая может быть решена по-разному. Мы воспользуемся готовым решением - &lt;a href=&quot;https://docs.python.org/3/library/importlib.html&quot;&gt;importlib&lt;/a&gt;. Сильно синтетический пример:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;importlib&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# some code
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;importlib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;import_module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'module.'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'.that'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;module.default&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Кстати, если Вас интересует скорость конкатенации строк и вообще какие бывают способы, то вот тут можно &lt;a href=&quot;https://stackoverflow.com/a/38362140/15966204&quot;&gt;прочитать об этом&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;как-определить-тип-операционной-системы-в-python&quot;&gt;Как определить тип операционной системы в python&lt;/h2&gt;

&lt;p&gt;И напоследок, если вы гоняете все это между машинами с разнымси осями или используете зависимые от операционной системы сборки, то все становится очень просто. К примеру, вот так можно запускать &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;selenium&lt;/code&gt; под windows не прописывая пути к гекодрайверу, а кинув его в удобную нам папку.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;os&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;selenium&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;webdriver&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'nt'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;driver&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;webdriver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Firefox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;executable_path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r'C:\nowhere\gekodriver\geckodriver.exe'&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;driver&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;webdriver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Firefox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;предостережение&quot;&gt;Предостережение&lt;/h2&gt;

&lt;p&gt;Все не так уж и прозаично. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;locals()&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;globals()&lt;/code&gt; не всегда приносят то, что нам нужно, а игры с &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exec()&lt;/code&gt; могут быть небезопасны. К тому же вы наверное заметили, что мы просто косплеим настоящий импорт - при импорте происходит практически тоже самое, только явно. Мы же добавляет переменные в контекст неявно и линтер будет страдать, а мы вместе с ним. Делать так на самом деле не надо, но иногда… Собственно, that all folks! :)&lt;/p&gt;</content><author><name>Klepikov Konstantin</name></author><category term="python" /><summary type="html"></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://konstantinklepikov.github.io/assets/img/110621-01.png" /><media:content medium="image" url="https://konstantinklepikov.github.io/assets/img/110621-01.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Данные изображения в компьютерном зрении. Пространственное представление.</title><link href="https://konstantinklepikov.github.io/2021/05/17/computer-vision-data-of-images.html" rel="alternate" type="text/html" title="Данные изображения в компьютерном зрении. Пространственное представление." /><published>2021-05-17T00:00:00+02:00</published><updated>2021-05-17T00:00:00+02:00</updated><id>https://konstantinklepikov.github.io/2021/05/17/computer-vision-data-of-images</id><content type="html" xml:base="https://konstantinklepikov.github.io/2021/05/17/computer-vision-data-of-images.html">&lt;p&gt;&lt;img src=&quot;../../../assets/img/17052021-01.jpg&quot; alt=&quot;Данные изображения в компьютерном зрении. Пространственное представление.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Любое изображение можно определить в пространственной или частотной области. В данной статье рассматривается определение данных в пространственной области.&lt;/p&gt;

&lt;h2 id=&quot;изображение-в-пространственной-области&quot;&gt;Изображение в пространственной области&lt;/h2&gt;

&lt;p&gt;Цифровое изображение определяется через дискретизацию непрерывных аналоговых данных в пространственной области. Такая область состоит из прямоугольного массива пикселей &lt;script type=&quot;math/tex&quot;&gt;(x, y, u)&lt;/script&gt;, каждый из которых является комбинацией местоположения &lt;script type=&quot;math/tex&quot;&gt;(x, y) \in \mathbb{Z}^2&lt;/script&gt; (здесь &lt;script type=&quot;math/tex&quot;&gt;\mathbb{Z}&lt;/script&gt; - множество целых чисел, а точки образуют регулярную сетку) и значения &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt;, представляющего отсчета в точке &lt;script type=&quot;math/tex&quot;&gt;(x, y)&lt;/script&gt;. Формальное определние изображения &lt;script type=&quot;math/tex&quot;&gt;I&lt;/script&gt; на прямоугольном множестве &lt;script type=&quot;math/tex&quot;&gt;\Omega&lt;/script&gt; (носитель или carrier &lt;script type=&quot;math/tex&quot;&gt;I&lt;/script&gt;):&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\Omega = \{(x, y) : \leq x \leq N_{cols} \wedge 1 \leq y \leq N_{rows}\} \subset \mathbb{Z}^2&lt;/script&gt;

&lt;p&gt;при условии, что &lt;script type=&quot;math/tex&quot;&gt;N_{cols} \geq 1, N_{rows} \geq 1&lt;/script&gt;, а система координат левосторонняя.&lt;/p&gt;

&lt;h3 id=&quot;пиксели&quot;&gt;Пиксели&lt;/h3&gt;

&lt;p&gt;Два способа геометрической интерпретации пикселя - в виде ячейки сетки или в виде меток в узлах сеток, являющихся центрами ячеек сетки.&lt;/p&gt;

&lt;p&gt;Модель ячейки сетки предполагает, что пиксель - это закрашенный одним цветом квадрат. Модель узла сетки предполагает, что пиксель - узел сетки, помеченный значением изображения.&lt;/p&gt;

&lt;p&gt;Пиксели сами по себе не определяют никаких отношений смежности. В модели ячеек сетки пиксели смежны тогда и только тогда, когда соответствующие им квадраты имеют смежную сторону. Другой вариант определения смежности - считать смежными различные квадраты, имеющие хотя бы одну общую сторону или вершину.&lt;/p&gt;

&lt;h3 id=&quot;окна&quot;&gt;Окна&lt;/h3&gt;

&lt;p&gt;Окном изображения &lt;script type=&quot;math/tex&quot;&gt;W_p^{m, n}(I)&lt;/script&gt; называется часть изображения &lt;script type=&quot;math/tex&quot;&gt;m \times n&lt;/script&gt;, спозиционированная относительно начального пикселя &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;. По уиолчанию считается, что &lt;script type=&quot;math/tex&quot;&gt;m, n&lt;/script&gt; нечетные, а &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; центр окна.&lt;/p&gt;

&lt;h3 id=&quot;основные-статистики-изображения&quot;&gt;Основные статистики изображения&lt;/h3&gt;

&lt;p&gt;В компьютерном зрении в качестве области скалярного изображения часто рассматривают отрезок вещественных чисел &lt;script type=&quot;math/tex&quot;&gt;[0, 1] \in \mathbb{R}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Для &lt;strong&gt;скалярных изображений&lt;/strong&gt; выбираются целые числа &lt;script type=&quot;math/tex&quot;&gt;u \in {0, 1, ..., 2^{\alpha} - 1}&lt;/script&gt;. Такие значения интерпретируются как уровни яркости, 0 соответствует черному, а &lt;script type=&quot;math/tex&quot;&gt;2^{\alpha} - 1&lt;/script&gt; белому, остальные уровни линейно интерполируются между белым и черным. Стандартом &lt;script type=&quot;math/tex&quot;&gt;\alpha&lt;/script&gt; может быть 8, 16 и т.д., в текущий момент 16.&lt;/p&gt;

&lt;p&gt;В &lt;strong&gt;бинарном изображении&lt;/strong&gt; пиксели приобретают только два значения - белый и черный.&lt;/p&gt;

&lt;p&gt;В &lt;strong&gt;векторных изображениях&lt;/strong&gt; число каналов больше одного, значениями изображений являются векторы &lt;script type=&quot;math/tex&quot;&gt;(u_1, u_2, ..., u_{N})&lt;/script&gt;. К примеру, в RGB три канала - красный, зеленый и синий, каждый канал при этом представляет из себя просто скалярное изображение.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Среднее&lt;/strong&gt; или средний уровень яркости.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\mu_I = \frac{1}{N_{cols} \times N_{rows}} \sum_{x=1}^{N_{cols}} \sum_{y=1}^{N_{rows}} I(x, y)&lt;/script&gt;

&lt;p&gt;здесь &lt;script type=&quot;math/tex&quot;&gt;\| \Omega \| = N_{cols}, \times N_{rows}&lt;/script&gt; - мощность носителя &lt;script type=&quot;math/tex&quot;&gt;\Omega&lt;/script&gt;, содержащего все пиксели.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Дисперсия&lt;/strong&gt; и &lt;strong&gt;стандартное отклонение&lt;/strong&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\sigma^2_I = [\frac{1}{\| \Omega \|} \sum_{(x, y) \in \Omega} I(x, y)^2] - \mu^2_I&lt;/script&gt;

&lt;p&gt;Квадратный корень из дисперсии - это стандартное отклонение. Такое представление дисперсии позволяет считать среднее и дисперсию одновременно при первом проходе через изображение.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Гистограмма&lt;/strong&gt; - это таблица частот. Гистограмма реализует представление скалярного изображения или одного из каналов векторного изображения.&lt;/p&gt;

&lt;p&gt;Абсолютные частоты (сколько раз значение &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; встречается в &lt;script type=&quot;math/tex&quot;&gt;\Omega&lt;/script&gt;)&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;H_i(u) = |{(x, y) \in \Omega : I(x, y) = u}|&lt;/script&gt;

&lt;p&gt;Относительные частоты - значения, распределенные между 0 и 1:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;h_I(u) = \frac{H_I(u)}{\| \Omega \|}&lt;/script&gt;

&lt;p&gt;Абсолютная гистограмма представляется значениями &lt;script type=&quot;math/tex&quot;&gt;H_I(0), H_I(1), ..., H_I(G_{max})&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Для кумулятивных гистограмм вычисляются абсолютная и относительная кумулятивные частоты:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;C_I(u) = \sum_{v=0}^u H_I(v)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;c_I(u) = \sum_{v=0}^u h_I(v)&lt;/script&gt;

&lt;p&gt;Дисперсия, мат.ожидание и другие статистики вычисляются так-же для окон. В процессе анализа можно классифицировать окна по категориям, к примеру как содержащие однородные области, с низкой или высокой контрастностью, содержащие границу областей и т.д.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Контрастность&lt;/strong&gt; определяется как средняя абсолютная величина разности между значением пикселя и средним значением соседних пикселей.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;C(I) = \frac{1}{\| \Omega \|} \sum_{(x, y) \in \Omega} | I(x, y) - \mu_{A(x, y)} |&lt;/script&gt;

&lt;h3 id=&quot;пространственные-и-временные-меры&quot;&gt;Пространственные и временные меры&lt;/h3&gt;

&lt;p&gt;Для получения полезной информации визуализируются профили яркости, определяемые одномерными сечениями скалярных массивов данных. По сути, это окно, одна из сторон которого имеет значение 1. Для профилей яркости можно считать все вышеуказанные статистики.&lt;/p&gt;

&lt;p&gt;Гистограммы и профили яркости - это пространственные статистики значений. Чтобы получить временные статистики, рассматривается последовательность изображений, полученных на одном и том же носителе &lt;script type=&quot;math/tex&quot;&gt;\Omega&lt;/script&gt;. Для лучшего понимания распределения значений пространственных метрик вводятся скалярные меры данных, которые сопоставляют одному кадру &lt;script type=&quot;math/tex&quot;&gt;I&lt;/script&gt; одно число. Сравниваются различные меры данных для заданного дискретного временного интервала, в результате чего получаются временные статистики.&lt;/p&gt;

&lt;p&gt;Временные статистики определяют функции, которые, при нормировке, позволяют оценить &lt;strong&gt;расстояние&lt;/strong&gt;, в частности &lt;script type=&quot;math/tex&quot;&gt;L_1&lt;/script&gt; и &lt;script type=&quot;math/tex&quot;&gt;L_2&lt;/script&gt; нормы. Кроме того, оценивается структурное подобие мер данных - функции структурно подобны, когда расстояние между ними близко к нулю, а локальные максимумы и минимумы функций находятся приблизительно в одних и тех же точках.&lt;/p&gt;

&lt;h3 id=&quot;ступенчато-градиентная-модель-step-edge-model&quot;&gt;Ступенчато-градиентная модель (step-edge model)&lt;/h3&gt;

&lt;p&gt;Границы на изображениях предоставляют важные данные о содержании изображения. Границы определяются изменением локальных производных. Такие границы могут представлять из себя как идеальные “ступеньки”, так и зашумленные или линейные переходы, резкие или плавные изломы.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../assets/img/17052021-02.png&quot; alt=&quot;step-edge model&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Для оценки локальных производных значение изображения интерпретируют как аппликатуру некоторой поверхности в точке расположения пикселя. При такой интерпретации изображение определяет долины, плато, плавные или крутые склоны, т.е. имеет рельеф. Значения частных производных по &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; и по &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt; позволяют вычислить градиент высоты аппликатуры. Границы находятся в точках, где модуль градиента достигает локального максимума:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;||\mathbf{grad} I ||_2 = \sqrt{(\frac{dI}{dx})^2 + (\frac{dI}{dy})^2}&lt;/script&gt;

&lt;p&gt;Кроме того, вторые производные определяются в лаплассиан &lt;script type=&quot;math/tex&quot;&gt;I&lt;/script&gt;, который является скаляром. Границы находятся там, где лаплассиан переходит через 0.&lt;/p&gt;</content><author><name>Klepikov Konstantin</name></author><category term="computer-vision" /><summary type="html"></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://konstantinklepikov.github.io/assets/img/17052021-01.jpg" /><media:content medium="image" url="https://konstantinklepikov.github.io/assets/img/17052021-01.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Алгоритм Page Rank</title><link href="https://konstantinklepikov.github.io/2021/02/19/page-rank.html" rel="alternate" type="text/html" title="Алгоритм Page Rank" /><published>2021-02-19T00:00:00+02:00</published><updated>2021-02-19T00:00:00+02:00</updated><id>https://konstantinklepikov.github.io/2021/02/19/page-rank</id><content type="html" xml:base="https://konstantinklepikov.github.io/2021/02/19/page-rank.html">&lt;p&gt;&lt;img src=&quot;../../../assets/img/190221banner.png&quot; alt=&quot;Алгоритм Page Rank&quot; /&gt;&lt;/p&gt;

&lt;p&gt;В данной статье я разберу принцип работы алгоритма Page Rank, который был предложен Лари Пейдж и Сергеем Брином для ранжирования веб-страниц для поискового сервиса Google.&lt;/p&gt;

&lt;p&gt;Фундаментальная идея заключалась в том, что значимость страниц в интернете неравноценна. Некоторые страницы очевидно были важнее остальных и возникла необходимость в их ранжировании по значимости.&lt;/p&gt;

&lt;p&gt;На момент изобретения алгоритма, в 1998 году, WWW по большей части состоял из страниц, доступных для индексирования, т.е. большинство ссылок было навигируемыми. Сеть можно было представить как большую марковскую цепь или граф, в котором веб-страницы являлись состояниями (нодами), а гиперссылки переходами между состояниями (ребрами графа). В этой концепции любая страница имела конечное число исходящих ссылок. Если предполагать, что пользователь (серфер) переходит по ссылкам (серфит) случайным образом, а вероятности перехода по любой из исходящих ссылок равновероятны, то вероятность такого перехода со страницы &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; на страницу &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; выражается как &lt;script type=&quot;math/tex&quot;&gt;P_(ij) = \frac{1}{m}&lt;/script&gt;, где &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; - число исходящих ссылок для данной страницы. Для страниц без ссылок вероятность принимается, как равная нулю. На этом простом принципе строился алгоритм ранжирования page rank.&lt;/p&gt;

&lt;p&gt;Для реализации идеи алгоритма необходимо принять несколько обобщений:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;все страницы имеют разную значимость&lt;/li&gt;
  &lt;li&gt;ссылки передают сообщения (голоса) от одной страницы к другой. Страница более важна, если она собирает больше голосов&lt;/li&gt;
  &lt;li&gt;голоса более важных страниц более важны&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;реализация-page-rank&quot;&gt;Реализация page rank&lt;/h2&gt;

&lt;p&gt;Как посчитать важность страниц и важность голосов, которые передают страницы через ссылки?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;каждая ссылка голосует пропорционально важности ссылающейся страницы&lt;/li&gt;
  &lt;li&gt;важность страницы делится между исходящими ссылками пропорционально количеству этих ссылок. Если страница &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; имеет важность &lt;script type=&quot;math/tex&quot;&gt;R_i&lt;/script&gt; и &lt;script type=&quot;math/tex&quot;&gt;d_i&lt;/script&gt; исходящих ссылок, то каждая такая ссылка получает &lt;script type=&quot;math/tex&quot;&gt;\frac{R_i}{d_i}&lt;/script&gt; важность&lt;/li&gt;
  &lt;li&gt;каждая страница имеет важность, равную сумме входящих голосов (важностей входящих в страницу ссылок)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;В примере: &lt;script type=&quot;math/tex&quot;&gt;R_j = \frac{R_i}{3} + \frac{R_k}{4}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../assets/img/190221-01.png&quot; alt=&quot;page rank visualization&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Иными словами, ранг &lt;script type=&quot;math/tex&quot;&gt;R_j&lt;/script&gt; страницы можно посчитать так: &lt;script type=&quot;math/tex&quot;&gt;R_j = \underset{j \rightarrow i}\sum \frac{R_i}{d_i}&lt;/script&gt;, где &lt;script type=&quot;math/tex&quot;&gt;d_i&lt;/script&gt; - исходящая степень (out degree) ноды &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Очевидно, что для подсчета ранга каждой страницы в сети нам необходимо знать весь граф со всеми связями. Кроме того, необходимо решить, будем ли мы учитывать петли (ссылки страниц на самих себя). Модель алгоритма выглядит так: нам необходимо построить граф сети, инициализировать ноды некими значениями, а затем в итеративном режиме обновлять значения для каждой ноды до тех пор, пока значения рангов не стабилизируются (перестанут изменяться либо их изменения не будут превышать некое заранее известное значение).&lt;/p&gt;

&lt;p&gt;Мы можем реализовать идею алгоритма в векторном виде. Пусть страница &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; имеет &lt;script type=&quot;math/tex&quot;&gt;d_j&lt;/script&gt; исходящих связей. Если &lt;script type=&quot;math/tex&quot;&gt;j \rightarrow i&lt;/script&gt;, тогда мы можем сформулировать стохастическую матрицу &lt;script type=&quot;math/tex&quot;&gt;\mathbf{M}_{ij} = \frac{1}{d_j}&lt;/script&gt;, такую, что сумма по каждой колонке равна 1. Для страницы &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; мы имеем вектор важности &lt;script type=&quot;math/tex&quot;&gt;r_i&lt;/script&gt;, такой что выполняется &lt;script type=&quot;math/tex&quot;&gt;\underset{i}\sum r_i = 1&lt;/script&gt;. Тогда на каждой итерации &lt;script type=&quot;math/tex&quot;&gt;\mathbf{r}_{next time} = \mathbf{M} \times \mathbf{r}_{previous time}&lt;/script&gt;, где &lt;script type=&quot;math/tex&quot;&gt;r = \underset{j \rightarrow i}\sum \frac{R_i}{d_i}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Алгоритм так же можно интерпретировать с точки зрения концепции случайного блуждания по графу;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;в момент &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; серфер находится на странице &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;в момент &lt;script type=&quot;math/tex&quot;&gt;t+1&lt;/script&gt; он переходит на случайную страницу по исходящей ссылке&lt;/li&gt;
  &lt;li&gt;повторить заданное число раз&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;При такой реализации можно полагать, что в момент времени &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; есть некая вероятность &lt;script type=&quot;math/tex&quot;&gt;P(t)&lt;/script&gt; перехода серфера со страницы &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; на следующую страницу. Тогда &lt;script type=&quot;math/tex&quot;&gt;P(t+1) = \mathbf{M} \times P(t)&lt;/script&gt; и &lt;script type=&quot;math/tex&quot;&gt;P(t)&lt;/script&gt; - это не что иное, как вероятностное распределение через все страницы сети.&lt;/p&gt;

&lt;p&gt;В этой (и предыдущей) интерпретации нетрудно заметить, что &lt;script type=&quot;math/tex&quot;&gt;\mathbf{M}&lt;/script&gt; в каждый момент времени остается неизменной, что позволяет сформулировать вычислительно разрешимый алгоритм оценки page rank.&lt;/p&gt;

&lt;p&gt;Для реализации подсчета page rank используется power iteration. Выглядит это так:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;инициализировать все ноды графа значением &lt;script type=&quot;math/tex&quot;&gt;r^{(0)} = [\frac{1}{N}, \frac{1}{N}, ...\frac{1}{N}]^T&lt;/script&gt;, где &lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt; - число нод в графе&lt;/li&gt;
  &lt;li&gt;проитерировать по &lt;script type=&quot;math/tex&quot;&gt;\mathbf{r}^{(t+1)} = \mathbf{M} \times \mathbf{r}^{(t)}&lt;/script&gt;, где &lt;script type=&quot;math/tex&quot;&gt;\mathbf{r}_{j}^{(t+1)} = \underset{j \rightarrow i}\sum \frac{r_{i}^{(t)}}{d_i}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;остановиться, когда &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\vert\mathbf{r}^{(t+1)} - \mathbf{r}^{(t)}\vert_1 &lt; \varepsilon %]]&gt;&lt;/script&gt;, где &lt;script type=&quot;math/tex&quot;&gt;\varepsilon&lt;/script&gt; некое заранее известное значение (можно использовать и другую норму)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Такой подход показывает сходимость примерно на 50 итерациии.&lt;/p&gt;

&lt;h2 id=&quot;проблемы-page-rank&quot;&gt;Проблемы page rank&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;некоторые страницы - это dead ends (нет исходящих ссылок)&lt;/li&gt;
  &lt;li&gt;часть страниц - это spider traps (исходящие ссылки двигаясь от страницы к странице приводят к образованию цикла)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Первая проблема ведет к утечке важности. Вторая к незапланированному сбору важности страницами, находящимися в цикле.&lt;/p&gt;

&lt;p&gt;Решение для spider trap: в каждый момент времени серфер, который перемещается по сети, имеет две опции:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;с вероятностью &lt;script type=&quot;math/tex&quot;&gt;\beta&lt;/script&gt; перейти по случайной ссылке далее в соответствии с основным сценарием алгоритма&lt;/li&gt;
  &lt;li&gt;с вероятностью &lt;script type=&quot;math/tex&quot;&gt;1 - \beta&lt;/script&gt; переместиться на случайную ноду в графе (телепорт)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;На практике &lt;script type=&quot;math/tex&quot;&gt;\beta \approx 0.8 ... 0.9&lt;/script&gt;. Для dead ends необходимо принять &lt;script type=&quot;math/tex&quot;&gt;\beta = 1&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Именно такое решение было предложено в оригинальном решении (см. &lt;a href=&quot;https://snap.stanford.edu/class/cs224w-readings/Brin98Anatomy.pdf&quot;&gt;публикацию&lt;/a&gt;) Лари Пейджа и Сергея Брина в 1998 году.&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;r_j = \underset{j \rightarrow i}\sum \beta \frac{r_i}{d_i} + (1 - \beta)\frac{1}{N}&lt;/script&gt; или в матричном представлении &lt;script type=&quot;math/tex&quot;&gt;A = \beta M + (1 - \beta)[\frac{1}{N}]_{N \times N}&lt;/script&gt;, где &lt;script type=&quot;math/tex&quot;&gt;[\frac{1}{N}]_{N \times N}&lt;/script&gt; - матрица, в которой все значения равны &lt;script type=&quot;math/tex&quot;&gt;\frac{1}{N}&lt;/script&gt;&lt;/p&gt;

&lt;h2 id=&quot;как-на-самом-деле-считается-page-rank&quot;&gt;Как на самом деле считается page rank&lt;/h2&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;r^{new} = A \times r^{old}&lt;/script&gt;. Матрица &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; содержит &lt;script type=&quot;math/tex&quot;&gt;N^2&lt;/script&gt; значений. Каждое значение стоит 4 байта памяти. Это означает матрица &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; для миллиона страниц (а в современном интернете содержится несколько миллиардов веб-сайтов  и сотни миллиардов страниц) начинает занимать пространственно-неразрешимое место в памяти. К счастью, эта матрица разреженная. Мы можем использовать разреженную матрицу &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;, предварительно выкинув из нее dead ends.&lt;/p&gt;

&lt;p&gt;Такой подход существенно сокращает место для хранения матрицы, однако появляется новая проблема: &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\sum r_{ji} &lt; 1 %]]&gt;&lt;/script&gt; т.к. мы выкинул dead ends. Решением является ренормализация.&lt;/p&gt;

&lt;p&gt;В итоге алгоритм page rank выглядит так (реализация взята из лекций стэндфордского курса &lt;a href=&quot;http://web.stanford.edu/class/cs224w/&quot;&gt;cs224w&lt;/a&gt;):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../assets/img/190221-02.png&quot; alt=&quot;page rank complete algorythm&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Подробную реализацию алгоритма можно посмотреть &lt;a href=&quot;https://en.wikipedia.org/wiki/PageRank&quot;&gt;на странице в wiki&lt;/a&gt;, где представлены имплементации на разных языках программирования.&lt;/p&gt;

&lt;h2 id=&quot;варианты-и-применение-page-rank&quot;&gt;Варианты и применение page rank&lt;/h2&gt;

&lt;p&gt;Существует несколько дополнительных реализаций page rank. Например можно задать разную вероятность телепорта для разных нод. Так можно локализовать телепорт в области, близкой к ноде, из которой осуществляется перемещение - это в свою очередь ранажирует ноды в локальной близости. Другой подход - телепортировать “серфера” всегда в одну и ту же ноду (random walk with restart).&lt;/p&gt;

&lt;p&gt;В настоящий момент page rank для ранжирования интернет-страниц - это уже история. В таком контексте алгоритм не используется google начиная с 2007 года. На смену page rank и подобным схемам пришли смешанные модели ранжирования, основанные на поведенчиских признаках и удовлетворенности пользователя. Да и сам интернет сильно изменился. Теперь большинство страниц не индексируется, а большинство ссылок - это лайки, посты, коментарии, внутренняя навигация и т.д.&lt;/p&gt;

&lt;p&gt;Тем не менее page rank по-прежнему активно используется в исследованиях графов и сетей, а в интернете применяется в ранжировании для составления рекомендаций.&lt;/p&gt;</content><author><name>Klepikov Konstantin</name></author><category term="page-rank" /><category term="algorithms" /><category term="graphs" /><category term="cs224w" /><summary type="html"></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://konstantinklepikov.github.io/assets/img/190221banner.png" /><media:content medium="image" url="https://konstantinklepikov.github.io/assets/img/190221banner.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Фишки pandas: часть 1</title><link href="https://konstantinklepikov.github.io/2021/01/19/fishki-pandas-part-1.html" rel="alternate" type="text/html" title="Фишки pandas: часть 1" /><published>2021-01-19T00:00:00+02:00</published><updated>2021-01-19T00:00:00+02:00</updated><id>https://konstantinklepikov.github.io/2021/01/19/fishki-pandas-part-1</id><content type="html" xml:base="https://konstantinklepikov.github.io/2021/01/19/fishki-pandas-part-1.html">&lt;p&gt;&lt;img src=&quot;../../../assets/img/pandas01.jpg&quot; alt=&quot;Фишки pandas: часть 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Стартую серию заметок про различные проблемы и фишки, с которыми мне пришлось столкнуться в python библиотеке pandas. В этом “выпуске”:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;метод pandas apply() не поддерживает аргумент axis. TypeError: &amp;lt;lambda&amp;gt;() got an unexpected keyword argument ‘axis’&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ValueError: The truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;как заменить все значения одного типа на какое-то одно значение в pandas&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TypeError: No matching signature found при реализации метода fillna()&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;как отобразить в окне браузера все строки датафрейма в jupyter notebook&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;метод-pandas-apply-не-поддерживает-аргумент-axis-typeerror-lambda-got-an-unexpected-keyword-argument-axis&quot;&gt;Метод pandas apply() не поддерживает аргумент axis. TypeError: &amp;lt;lambda&amp;gt;() got an unexpected keyword argument ‘axis’&lt;/h2&gt;

&lt;p&gt;Проблема банальна: вы применяете метод серии, а не фрейма:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;df&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DataFrame&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'col1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'col2'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]})&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'col1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'col1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;axis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
TypeError: &amp;lt;lambda&amp;gt;() got an unexpected keyword argument 'axis'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;У версии метода для серии нет аргумента axis. Решение - или применять к фрейму или убрать аргумент axis&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'col1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'col1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]].&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;axis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'col1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'col1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;valueerror-the-truth-value-of-a-series-is-ambiguous-use-aempty-abool-aitem-aany-or-aall&quot;&gt;ValueError: The truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().&lt;/h2&gt;

&lt;p&gt;Ошибку можно получить при попытке использовать логические методы в pandas&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;df&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'col1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'col1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
ValueError: The truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Проблема в том, что массивы numpy и pandas не имеют логических значений и связанно это с тем, что не всегда возможно установить когда объект True, а когда он False. В некоторых случаях мы можем считать, что массив True, только если он не нулевой длины, в некоторых мы можем ожидать, что он True, только если все объекты массива не False. Иными словами, так-как пользователи ожидают различное поведение, библиотека просто выбрасывает ValueError, чтобы предоставить пользователю самостоятельно определить какую именно логику необходимо применить при сравнении.&lt;/p&gt;

&lt;p&gt;Как решить эту проблему зависит от контекста. Можно воспользоваться более явным сравнением, к примеру, логическими операторами &amp;amp;, | и т.д.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;df&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'col1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'col1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;как-заменить-все-значения-одного-типа-на-какое-то-одно-значение-в-pandas&quot;&gt;Как заменить все значения одного типа на какое-то одно значение в pandas&lt;/h2&gt;

&lt;p&gt;Задача часто появляется, когда, к примеру, нужно обнулить множество значений в таблице. Используем метод &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.mask.html&quot;&gt;mask&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'col1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'col1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'col1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;666&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;typeerror-no-matching-signature-found-при-реализации-метода-fillna&quot;&gt;TypeError: No matching signature found при реализации метода fillna()&lt;/h2&gt;

&lt;p&gt;Эта редкая проблема встречается при использовании метода fillna() с аргументом типа method=’ffill’. Если вычисления не слишком затратные, можно реализовать решение с переводом в тип ‘object’:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'this'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'that'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'this'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'that'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;astype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'object'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fillna&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ffill&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;astype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;float16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Естественно, переопределите свой тип данных для выхода.&lt;/p&gt;

&lt;h2 id=&quot;как-отобразить-в-окне-браузера-все-строки-и-колонки-датафрейма-в-jupyter-notebook&quot;&gt;Как отобразить в окне браузера все строки и колонки датафрейма в jupyter notebook&lt;/h2&gt;

&lt;p&gt;Иногда нужно посмотреть на результат преобразований и убедиться, что нет пропусков или получена ожидаемая структура данных. Jupyter notebook сокращает вывод. Решение можно получить через option_context()&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;option_context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'display.max_rows'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'display.max_columns'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; 
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Кстати, обратите внимание как используется менеджер контекста для того, чтобы не изменять глобальные настройки отображения.&lt;/p&gt;</content><author><name>Klepikov Konstantin</name></author><category term="pandas," /><category term="python" /><summary type="html"></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://konstantinklepikov.github.io/assets/img/pandas01.jpg" /><media:content medium="image" url="https://konstantinklepikov.github.io/assets/img/pandas01.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Запускаем machine learning MVP: инструкция о том, как быстро презентовать идеи</title><link href="https://konstantinklepikov.github.io/2021/01/10/zapuskaem-machine-learning-mvp.html" rel="alternate" type="text/html" title="Запускаем machine learning MVP: инструкция о том, как быстро презентовать идеи" /><published>2021-01-10T00:00:00+02:00</published><updated>2021-01-10T00:00:00+02:00</updated><id>https://konstantinklepikov.github.io/2021/01/10/zapuskaem-machine-learning-mvp</id><content type="html" xml:base="https://konstantinklepikov.github.io/2021/01/10/zapuskaem-machine-learning-mvp.html">&lt;p&gt;&lt;img src=&quot;../../../assets/img/100121banner.png&quot; alt=&quot;Запускаем machine learning MVP: инструкция о том, как быстро презентовать идеи&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Итак, есть идея и есть даже какая-то реализация в виде просчитанной модели, которая умеет, к примеру, классифицировать, распознавать или создавать новые объекты. Нам понятно как она устроена и, возможно, мы даже полностью понимаем математику, которая лежит в основе модели. Пришло время представить наше творение потенциальным инвесторам, будущим партнерам, публике на отчетной сессии хакатона или просто друзьям. Можно было бы воспользоваться сервисом типа &lt;a href=&quot;https://colab.research.google.com/&quot;&gt;colab&lt;/a&gt; или связанного с ними &lt;a href=&quot;https://www.kaggle.com/&quot;&gt;kaggle&lt;/a&gt; и опубликовать код “как есть”, но вот беда - те, кому мы хотим это показать плохо разбираются в коде, зато явно ждут чего-то эффектного. А строить полноценное приложение долго и дорого, необходимо разворачивать сервер и тратить время, которого и так нет. Как быть?&lt;/p&gt;

&lt;p&gt;Итак, вот требования быстрому старту:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;исходный код должен быть скрыт от пользователя - ведь мы же не хотим, чтобы ему стало скучно?&lt;/li&gt;
  &lt;li&gt;необходимо разместить наш проект в интернете, чтобы разные пользователи смогли познакомиться с нашим гениальным изобретением&lt;/li&gt;
  &lt;li&gt;наш проект должен получить готовые пользовательские интерфейсы, с помощью которых с ним можно было бы взаимодействовать&lt;/li&gt;
  &lt;li&gt;нам очень не хотелось бы погружаться в разные языки программирования, а тем более в гипертекстовую разметку и прочий фронтенд&lt;/li&gt;
  &lt;li&gt;точно необходимо избежать развертывания баз данных&lt;/li&gt;
  &lt;li&gt;все нужно сделать быстро и, что важно, бесплатно&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Такое чувство, что нужен какой-то zerocode, в котором есть чуть-чуть кода, но это не точно. Я нашел такое решение и в этой статье я расскажу о том, как развернуть наш МВП всего за пару дней.&lt;/p&gt;

&lt;h2 id=&quot;схема-проекта&quot;&gt;Схема проекта&lt;/h2&gt;

&lt;p&gt;В качестве примера я построю приложение, визуализирующее данные о covid-19 для Калининградской области. В нем мы будем показывать пользователям различные представления табличных данных, попробуем визуализировать распределения и тренды. Мне понадобится:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;где-то хранить и обновлять таблицы с данными&lt;/li&gt;
  &lt;li&gt;хранить код разработки приложения&lt;/li&gt;
  &lt;li&gt;реализовать в клиентском браузере отрисовку графиков&lt;/li&gt;
  &lt;li&gt;разместить актуальный код на сервере в интернете&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Для этого я буду использовать следующий стек технологий и инструментов:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.python.org/&quot;&gt;python&lt;/a&gt; я буду использовать, потому что в целом на нем большая часть полезных инстументов для data science: обработка данных, моделирование, бекенд. Скорее всего, если мы беремся за машинное обучение, то прототип будет создан на python, поэтому есть смысл готовить МВП на нем же. Отлично. Теперь вся задача сводится к тому, чтобы выполнить всю остальную реализацию на python&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://numpy.org/&quot;&gt;Numpy&lt;/a&gt;, &lt;a href=&quot;https://pandas.pydata.org/&quot;&gt;pandas&lt;/a&gt; обеспечат реализацию моей задачи: мне необходимо обработать данные, а результат вывести в виде графиков в приложении. Pandas, который написан поверх numpy, как раз для этого отлично подходит. С помощью этой библиотеки можно осуществлять численные операции над двумерными данными (таблицами), не теряя семантику. Это важно для создания быстрых прототипов, когда особо нет времени на оптимизацию и легко запутаться в идентификаторах.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://altair-viz.github.io/&quot;&gt;altair&lt;/a&gt; - инструмент визуализации на python. Сразу поставляет необходимый фронт, в т.ч. и интерактивный. К тому же у него довольно простой и разнообразный интерфейс кода, который позволяет строить сложные визуализации не дорабатывая саму библиотеку.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.streamlit.io/&quot;&gt;streamlit&lt;/a&gt; - с помощью этого продукта мы сделаем пользовательское приложение, тоже python. По сути streamlit оборачивает код на python, поставляет сервер и позволяет отображать результаты работы кода в вебе. Пакет специально был создан для МЛ-прототипирования, естественно нет речи о том, чтобы делать на нем что-то реально ценное, но мою задачу он решит идеально.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/&quot;&gt;github&lt;/a&gt; - тут будем хранить рабочий код и обновлять данные. Github обеспечит разработку и непрерывную интеграцию с сервером, где мы разместим streamlit-приложение. Github action понадобится для того, чтобы не бодаться с cron на сервере, а выполнять обновления данных там, где живет разработка.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://dashboard.heroku.com/apps&quot;&gt;heroku apps&lt;/a&gt; - облачный хостинговый и серверный сервис с возможностью бесплатного размещения python проектов. Выбор пал на него по нескольким причинам: бесплатный, python в комплекте, размещение в два клика, интеграция с github.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.google.com/sheets/about/&quot;&gt;google sheets&lt;/a&gt; в качестве замены базы данных.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Вот схема проекта. В гугл-таблицах мы будем агрегировать данные, затем на github с помощью github-action делать предобработку и сохранять результат в .csv. Пользовательское приложение будет собираться на heroku, а данные получать из .csv на github. В итоге у нас минимум серверной работы, нет базы данных, а весь код написан на python. То что нужно.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../assets/img/100121-01.png&quot; alt=&quot;cheeme&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;реализация&quot;&gt;Реализация&lt;/h2&gt;

&lt;p&gt;Python и все необходимые библиотеки у меня уже есть. Streamlit и altair довольно просто ставятся с &lt;a href=&quot;https://pypi.org/&quot;&gt;pypi&lt;/a&gt;. &lt;a href=&quot;https://git-scm.com/&quot;&gt;Git&lt;/a&gt; на моей локальной машине тоже установлен.&lt;/p&gt;

&lt;p&gt;Я создал новый аккаунт на heroku, указал, что разработка приложения будет вестись на python 3.8. Аккаунт на github у меня уже был. На гитхабе я создал отдельный репозиторий, main которого будет автомотически комититься на heroku при каждом обновлении. Интеграция гитхаба и heroku с автобилдами реализуется &lt;a href=&quot;https://devcenter.heroku.com/articles/github-integration&quot;&gt;в два клика&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Чтобы реализовать связку heroku-github мне понадобится такая структра проекта:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;.gitignore&lt;/li&gt;
  &lt;li&gt;.slugignore&lt;/li&gt;
  &lt;li&gt;Procefile&lt;/li&gt;
  &lt;li&gt;setup.sh&lt;/li&gt;
  &lt;li&gt;requirements.txt&lt;/li&gt;
  &lt;li&gt;файлы и каталоги приложения&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;В .gitignore добавлено все, что мы не хотим видеть в нашем репозитерии. На этот же файл смотрит и heroku при деплое.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://devcenter.heroku.com/articles/slug-compiler#ignoring-files-with-slugignore&quot;&gt;.slugignore&lt;/a&gt; понадобится для того, чтобы спрятать какие-то объекты, которые находятся в репозитории на github уже от heroku.&lt;/p&gt;

&lt;p&gt;В requirements.txt пропишем необходимые python пакеты. Heroku будет обновлять нужные библиотеки автоматически при деплое. К сожалению серверный установщик не подружился с тем набором версий пакетов, которые я указал в requirements.txt , но так-как мне не принципиально, то в конечном итоге я указал пакеты без версий: numpy, pandas, altair, streamlit&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://devcenter.heroku.com/articles/procfile&quot;&gt;Procefile&lt;/a&gt; реализует на heroku то, что нам нужно запустить при старте сервера. В моем случае все просто, я конфигурирую и запускаю сервер streamlit:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;web: sh setup.sh &amp;amp;&amp;amp; streamlit run main.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Простенькая конфигурация в setup.sh&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; ~/.streamlit/

&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;
[general]&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;
email = &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;oformleno@gmail.com&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;\n\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;
&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; ~/.streamlit/credentials.toml

&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;
[server]&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;
headless = true&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;
enableCORS=false&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;
port = &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$PORT&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;
&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; ~/.streamlit/config.toml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Само приложение я разбил на две части: пользовательскую часть и часть, которая будет готовить данные.&lt;/p&gt;

&lt;p&gt;Пользовательская часть в файле main.py содержит исполняемый код на python, который будет запускаться при доступе по адресу страницы приложения. Собственно этот код содержит в себе все, что взаимодействует с остальными данными на heroku и отображает пользовательский интерфейс. В первую очередь приложение потребляет данные, на основе которых строятся визуализации. Так как данных немного и у нас нет БД, я их получаю из .csv, который расположен на github. Данные я сразу преобразую в массив pandas с помощью read_csv(), а из массива сразу строю графики на altair.&lt;/p&gt;

&lt;p&gt;Далее, все что отрисовал altair, а так-же тексты, гиперссылки и другой контент отображается из python на страницу в браузере пользователя при помощи streamlit. У последнего довольно тривиальный &lt;a href=&quot;https://share.streamlit.io/daniellewisdl/streamlit-cheat-sheet/app.py&quot;&gt;набор методов&lt;/a&gt;, есть нужные мне &lt;a href=&quot;https://www.streamlit.io/components&quot;&gt;интеграции&lt;/a&gt;, довольно простая и понятная &lt;a href=&quot;https://docs.streamlit.io/en/stable/index.html&quot;&gt;документация&lt;/a&gt; и множество готовых решений от &lt;a href=&quot;https://discuss.streamlit.io/&quot;&gt;комьюнити&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;“Серверная часть” расположена в dataprocessor.py. Этот скрипт запускается на github с помощью github action и решает следующие задачи:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;google sheets позволяет агрегировать данные руками или регулярно выгружать туда данные скрапером, но в конечном итоге это не БД. Структура данных там архаична, есть пропуски, не хватает некоторых столбцов и значений, есть проблемы с форматом. К тому же таблица в неудобном excel-подобном формате. С помощью python скрипта я делаю препроцессинг данных и отдаю в репозиторий готовый к построению графиков csv&lt;/li&gt;
  &lt;li&gt;по той же причине (отсутствие БД) мне бы хотелось убрать все дорогостоящие вычисления подальше от пользователя&lt;/li&gt;
  &lt;li&gt;я сознательно отказался от cron на heroku, так как проект хостится бесплатно, а &lt;a href=&quot;https://devcenter.heroku.com/articles/scheduler&quot;&gt;heroku scheduler&lt;/a&gt; и подобные шедалеры либо неудобны, либо плохо управляемые, либо работают нерегулярно, либо платные&lt;/li&gt;
  &lt;li&gt;обновлять данные мне надо раз в 15 минут. Так как репозиторий на github бесплатный, соответствующий экшен мне тоже ничего не стоит и никак не лимитирован.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Выглядит громоздко, но на самом деле все просто! Поверьте, гораздо проще, чем возиться с базой данных (не стоит забывать, что я делаю МВП, времени в обрез, а деньги заканчиваются :)&lt;/p&gt;

&lt;p&gt;В репозитории проекта помимо веток разработки я создал отдельную ветку datasets, в которую будут складываться csv-файлы после выполнения экшена на github. Эта ветка будет виртуальным хранилищем наших данных - так-как репозиторий открытый, то и доступ к данным тоже может осуществляться по прямой ссылке. Ветку, очевидно, я никогда не стану сливать с main-ом и коммитить в нее буду только изменения в dataprocessor.py, скрипте, который отвечает за экшен на github.&lt;/p&gt;

&lt;p&gt;Забирать данные для препроцессинга с google sheets мы будем тоже по прямой ссылке вида;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://docs.google.com/spreadsheets/d/{file_id}/gviz/tq?tqx=out:csv&amp;amp;sheet={sheet_name}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Тут {file_id} айдишник моей таблицы, а {sheet_name} вкладка. Делаем таблицу публичной и будем разбирать ее в виде csv по вкладкам.&lt;/p&gt;

&lt;p&gt;Итак, у нас есть работающий процесс: забираем google таблицу в виде csv, обрабатываем в pandas, выкладываем в ветку репозитория на github, откуда таблицу видно на heroku. Осталось разобраться с экшенами.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.github.com/en/free-pro-team@latest/actions/quickstart&quot;&gt;Github action&lt;/a&gt; позволяет запускать исполняемые скрипты по времени или в ответ на события. В моем случае нужно по времени. Как собираются экшены можно почитать &lt;a href=&quot;https://docs.github.com/en/free-pro-team@latest/actions/learn-github-actions/introduction-to-github-actions&quot;&gt;тут&lt;/a&gt;. Я реализую следующий сценарий:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;раз в 15 минут&lt;/li&gt;
  &lt;li&gt;перейти на ветку datasets&lt;/li&gt;
  &lt;li&gt;установить python зависимости&lt;/li&gt;
  &lt;li&gt;выполнить dataprocessor.py&lt;/li&gt;
  &lt;li&gt;если есть изменеения в .csv файлах - сделать коммит в datasets&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;О том, как работать с python в github action можно прочитать &lt;a href=&quot;https://docs.github.com/en/free-pro-team@latest/actions/guides/building-and-testing-python&quot;&gt;здесь&lt;/a&gt;. Для реализации плана в основном репозитории я создал каталог .github, в нем подкаталог workflows, а в нем файл dataloader.yml. Github самостоятельно распознает наличие экшена и начнет его выполнять по расписанию. Получилось следующее:&lt;/p&gt;

&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Autoupdate raw-data&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;schedule&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;cron&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;*/15&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;*'&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;jobs&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;runs-on&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ubuntu-latest&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;strategy&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;matrix&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;python-version&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;3.8.6&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;steps&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;uses&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;actions/checkout@v2&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;datasets&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Set up Python $&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;uses&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;actions/setup-python@v2&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;python-version&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;$&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Cache pip&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;uses&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;actions/cache@v2&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;~/.cache/pip&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;$-pip-$&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;restore-keys&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;|&lt;/span&gt;
          &lt;span class=&quot;s&quot;&gt;$-pip-&lt;/span&gt;
          &lt;span class=&quot;s&quot;&gt;$-&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Install dependencies&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;|&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;python -m pip install --upgrade pip&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;if [ -f requirements.txt ]; then pip install -r requirements.txt; fi&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Run dataprocessor&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;|&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;python dataprocessor.py&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;uses&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;actions/upload-artifact@v2&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;raw-data&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;data/*.csv&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;retention-days&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;uses&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;stefanzweifel/git-auto-commit-action@v4&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;commit_message&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Autoupdate raw-data&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;branch&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;datasets&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;push_options&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;--force'&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;file_pattern&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;data/*.csv&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;мы создали экшен с названием Autoupdate raw-data&lt;/li&gt;
  &lt;li&gt;настроили cron на гитхабе с таймером в 15 минут&lt;/li&gt;
  &lt;li&gt;с помощью готового решения actions/checkout@v2 перескочили в ветку datasets&lt;/li&gt;
  &lt;li&gt;установили python 3.8 в окружении на github, а так-же все зависимости из requirements.txt. Чтобы не ходить по кругу несколько раз установка кешируется с помощью actions/cache@v2&lt;/li&gt;
  &lt;li&gt;выполнили dataprocessor.py&lt;/li&gt;
  &lt;li&gt;с помощью actions/upload-artifact@v2 получили артефакты выполнения скрипта. Это csv-шки. Указали, что будем хранить их ровно сутки.&lt;/li&gt;
  &lt;li&gt;с помощью stefanzweifel/git-auto-commit-action@v4 отправили их в ветку&lt;/li&gt;
  &lt;li&gt;по завершению экшена github сам сделал чекаут и подчистил следы :)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Немного пояснений в части артефактов. Гитхаб при исполнении экшенов создает объекты не в репозитории, а в отдельном пространстве. Они хранятся в архивированном виде и извне не доступны. Если мы хотим извлечь какие-то объекты в процессе обработки экшена, это необходимо выполнить отдельным действием.&lt;/p&gt;

&lt;p&gt;Вот немного ссылок: &lt;a href=&quot;https://docs.github.com/en/free-pro-team@latest/actions/reference/workflow-syntax-for-github-actions#about-yaml-syntax-for-workflows&quot;&gt;синтаксис&lt;/a&gt;, &lt;a href=&quot;https://docs.github.com/en/free-pro-team@latest/actions/reference/events-that-trigger-workflows#scheduled-events&quot;&gt;синтаксис шедалера&lt;/a&gt;, &lt;a href=&quot;https://github.com/actions/upload-artifact&quot;&gt;upload artifacts&lt;/a&gt;, &lt;a href=&quot;https://github.com/marketplace/actions/git-auto-commit&quot;&gt;autocommit&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Вот и все. Собираем: выгружаем данные в таблицы, коммитим на github, делаем pull request в main. Ждем деплоя на heroku. Ждем обработки в github action. &lt;a href=&quot;https://covid-kaliningrad.herokuapp.com/&quot;&gt;Смотрим результат&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/KonstantinKlepikov/covid-kaliningrad&quot;&gt;Репозиторий проекта тут&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;с-какими-проблемами-пришлось-столкнуться&quot;&gt;С какими проблемами пришлось столкнуться&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Преобразование в формат datatime в pandas иногда приносит сюрпризы. Можно получить перестановку местами дня и месяца. Это не баг, а небольшой фокус обработки, о котором можно и не знать. Заметить его трудно. В итоге на выходе можно получить что-то наподобии:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../../assets/img/040121-01.png&quot; alt=&quot;data-bug&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/36998540/pd-read-csv-not-correctly-parsing-date-month-field-when-set-parse-date-colum&quot;&gt;Решение проблемы&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Altair не работает с индексом pandas - его необходимо сбросить. Лучше всего кормить графики массивом данных, состощим из трех колонок: значения для оси X, маппинг названий для разных наборов данных, которые мы собираемся отобразить на графиках, и собственно непосредственно сами значения для оси Y&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Необходимо следить за типом данных в google sheets. Там может быть абсолютно неожиданные формат чисел или смешанный формат для числовых данных. Pandas поймет эти данные неправильно, но ошибку не выдаст. Особенно это касается чисел с плавающей точкой: мало того, что при неверно указанном формате pandas округлит значения, так еще и в гугл-таблицах значения содержатся с запятой вместо точки. Это придется обработать отдельно.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Не смотря на описание в heroku деплой там срабатывает не на релизы, а на коммиты в main github-репозитория. по этой причине я вынес обработку данных в отдельную ветку.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Округление float в numpy работает не так, как вы ожидаете. Проблема &lt;a href=&quot;https://github.com/pandas-dev/pandas/issues/35124&quot;&gt;известна&lt;/a&gt;, но не решена.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Удаляйте пустые столбцы в гугл-таблицах, иначе получите их в csv-файле.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;В собранном приложении streamlit отображает меню разработки (в нем несколько не сильно полезных инструментов типа перезагпузки страницы). Вы наверняка захотите это &lt;a href=&quot;https://discuss.streamlit.io/t/how-do-i-hide-remove-the-menu-in-production/362/10&quot;&gt;убрать&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;выводы&quot;&gt;Выводы&lt;/h2&gt;

&lt;p&gt;Предложенное решение позволяет быстро собрать серверное приложение с достаточным для презентации интерфейсом. База данных не нужна. Конфигурация сервера по сути не нужна. Работает на бесплатных хостингах с бесплатным кроном. Идеально для хакатонов - собирается за несколько часов до презентации. Работает из коробки.&lt;/p&gt;

&lt;p&gt;Пример, который я реализовал - это конечно по сути лапшекод написаный на коленке, Но именно это отражает идею MVP: собирай быстро, показывай и двигайся дальше. Задача заключалась в демонстрации простого решения поставленной цели. Надеюсь это будет Вам полезно.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/KonstantinKlepikov/covid-kaliningrad&quot;&gt;Репозиторий проекта&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://covid-kaliningrad.herokuapp.com/&quot;&gt;Результат работы&lt;/a&gt;&lt;/p&gt;</content><author><name>Klepikov Konstantin</name></author><category term="machine-learning," /><category term="mvp," /><category term="streamlit," /><category term="github," /><category term="python," /><category term="zerocode," /><category term="covid" /><summary type="html"></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://konstantinklepikov.github.io/assets/img/100121banner.png" /><media:content medium="image" url="https://konstantinklepikov.github.io/assets/img/100121banner.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Сверточные нейронные сети для графов. Часть 2 (практика)</title><link href="https://konstantinklepikov.github.io/2020/11/05/svertochnie-neyronnie-seti-dlja-grafov-chast-2-practica.html" rel="alternate" type="text/html" title="Сверточные нейронные сети для графов. Часть 2 (практика)" /><published>2020-11-05T00:00:00+02:00</published><updated>2020-11-05T00:00:00+02:00</updated><id>https://konstantinklepikov.github.io/2020/11/05/svertochnie-neyronnie-seti-dlja-grafov-chast-2-practica</id><content type="html" xml:base="https://konstantinklepikov.github.io/2020/11/05/svertochnie-neyronnie-seti-dlja-grafov-chast-2-practica.html">&lt;p&gt;Семинар, посвященный практике по графовым нейронным сетям, можно посмотреть на youtube:&lt;/p&gt;

&lt;div class=&quot;video-container&quot;&gt;
&lt;iframe src=&quot;https://www.youtube.com/embed/Hf7RYjxLemY&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;Вначале еще раз разбираем &lt;a href=&quot;/2020/10/19/svertochnie-neyronnie-seti-dlja-grafov-chast-1.html&quot;&gt;теоретическую часть вопроса&lt;/a&gt;. Затем смотрим простой пример на numpy. Затем проходим то же самое еще раз, но уже с pytorch. В заключение разбираем пример с pytorch geometric. Репозиторий с кодом размещен &lt;a href=&quot;https://github.com/KonstantinKlepikov/GCN_lect&quot;&gt;тут&lt;/a&gt;.&lt;/p&gt;</content><author><name>Klepikov Konstantin</name></author><category term="neural-network" /><category term="graphs" /><category term="convolutional" /><category term="cs224w" /><category term="GCN" /><category term="embedding" /><summary type="html">Семинар, посвященный практике по графовым нейронным сетям, можно посмотреть на youtube:</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://konstantinklepikov.github.io/assets/img/051120banner.png" /><media:content medium="image" url="https://konstantinklepikov.github.io/assets/img/051120banner.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Сверточные нейронные сети для графов. Часть 1</title><link href="https://konstantinklepikov.github.io/2020/10/19/svertochnie-neyronnie-seti-dlja-grafov-chast-1.html" rel="alternate" type="text/html" title="Сверточные нейронные сети для графов. Часть 1" /><published>2020-10-19T00:00:00+02:00</published><updated>2020-10-19T00:00:00+02:00</updated><id>https://konstantinklepikov.github.io/2020/10/19/svertochnie-neyronnie-seti-dlja-grafov-chast-1</id><content type="html" xml:base="https://konstantinklepikov.github.io/2020/10/19/svertochnie-neyronnie-seti-dlja-grafov-chast-1.html">&lt;p&gt;&lt;img src=&quot;../../../assets/img/191020banner.png&quot; alt=&quot;Сверточные нейронные сети для графов. Часть 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Графовые нейронные сети — молодое и перспективное направление развития нейронных сетей, нашедшее применение в анализе различных структур данных, например, социальных профилей, групп документов, в молекулярной биологии, трехмерных изображений и т.д. и т.п. В данной статье разбираются подходы к решению проблемы работы с графовыми данными.&lt;/p&gt;

&lt;p&gt;Главная сложность — разыскать такое представление графа, которое отобразит графовую структуру в модель машинного обучения. Решается это такими методами:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;графовые статистики&lt;/li&gt;
  &lt;li&gt;ядерные методы&lt;/li&gt;
  &lt;li&gt;манипуляции с признаками для оценки локальной близости&lt;/li&gt;
  &lt;li&gt;обучение представлению графа&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Представление информации в нодах или субграфах в виде векторов — проблема. Оказывается, как правило, данные содержатся в многомерном неевклидовом пространстве. Соответственно &lt;strong&gt;задача — перегнать многомерный вектор признаков в низкоразмерный, размерностью &lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt;, желательно из &lt;script type=&quot;math/tex&quot;&gt;\mathbb{R}&lt;/script&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Одним из основных подходов в решении данной задачи является representation learning. Подход сводится к созданию эмбеддингов для нод или субграфов в графе, что позволяет перевести данные в область с низкой размерностью. Такие эмбеддинги уже можно использовать в различных моделей ML.&lt;/p&gt;

&lt;p&gt;Если мы имеем граф &lt;script type=&quot;math/tex&quot;&gt;G = (V, E)&lt;/script&gt; и ассоциированные с ним матрицу смежности &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; и матрицу &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt;, содержащую атрибуты нод, так что &lt;script type=&quot;math/tex&quot;&gt;X \in \mathbb{R}^{m \times \vert V \vert}&lt;/script&gt;, то задачей является получение векторов &lt;script type=&quot;math/tex&quot;&gt;z \in \mathbb{R}^d&lt;/script&gt; для каждой ноды, таких, что &lt;script type=&quot;math/tex&quot;&gt;d \ll \vert V \vert&lt;/script&gt;. (Данный подход справедлив и для ребер).&lt;/p&gt;

&lt;p&gt;Эту задачу решает такая модель:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;функция попарной похожести (pairwise similarity function) &lt;script type=&quot;math/tex&quot;&gt;S_g : V \times V \rightarrow \mathbb{R}^+&lt;/script&gt;, определенная над графом &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;. Функция измеряет схожесть между нодами.&lt;/li&gt;
  &lt;li&gt;энкодер, генерирующий эмбеддинги &lt;script type=&quot;math/tex&quot;&gt;ENC: V \rightarrow  \mathbb{R}^d&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;декодер, реконструирующий статистики графа из эмбеддингов &lt;script type=&quot;math/tex&quot;&gt;DEC : \mathbb{R}^d \times \mathbb{R}^d \rightarrow \mathbb{R}^+&lt;/script&gt; *&lt;/li&gt;
  &lt;li&gt;функция потерь (специфична для каждой задачи) - оценивает несоответствие между декодированным (оцененным) значением близости &lt;script type=&quot;math/tex&quot;&gt;DEC(\mathbf{z}_i, \mathbf{z}_j)&lt;/script&gt; и истинным &lt;script type=&quot;math/tex&quot;&gt;S_g(v_i, v_j)&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;* для двух нод в графе &lt;script type=&quot;math/tex&quot;&gt;DEC(ENC(v_i), ENC(v_j)) = DEC(\mathbf{z}_i, \mathbf{z}_j) \approx S_g(v_i, v_j)&lt;/script&gt; декодер восстанавливает «попарную близость» нод в графе из эмбеддингов&lt;/p&gt;

&lt;p&gt;Самый простой метод — &lt;strong&gt;shallow encoding&lt;/strong&gt;, для которого мы можем определить энкодер как функцию: &lt;script type=&quot;math/tex&quot;&gt;ENC(v_i) = Z v_i&lt;/script&gt;, где &lt;script type=&quot;math/tex&quot;&gt;Z \in \mathbb{R}^{m \times \vert V \vert}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../assets/img/191020-03.png&quot; alt=&quot;shallow&quot; /&gt;&lt;/p&gt;

&lt;p&gt;К подобным способам создания эмбеддингов относятся различные матричные факторизации (graph factorisation, GraRep, HOPE и т.д.) и RandomWalk модели (DeepWalk, node2wec).&lt;/p&gt;

&lt;p&gt;Проблемой shallow encoding является то, что в этом методе параметры нод не распространяются и не используются совместно в энкодере. Каждый вектор обучается отдельно от других. Число параметров растет как функция от количества нод &lt;script type=&quot;math/tex&quot;&gt;O(V)&lt;/script&gt;. Кроме того, подход не учитывает атрибуты нод, которые в большинстве случаев содержат важную информацию о графе. К тому же подход генерирует эмбеддинги только для данных, которые есть среди обучаемых. Модель проблематично обобщить на данные, которые модель никогда не видела.&lt;/p&gt;

&lt;p&gt;Чтобы справиться с недостатками shallow encoding, были изобретены генерализованные энкодер-декодер структуры: DNGR (deep neural graph representation) и SDNE (structural deep network embeddings), относящихся к автоэнкодерам, основанных на исследовании соседних нод в графе.&lt;/p&gt;

&lt;p&gt;Прямым решением для таких моделей является то, что каждая нода &lt;script type=&quot;math/tex&quot;&gt;v_i&lt;/script&gt; ассоциируется с высокаразмерным «вектором близости» &lt;script type=&quot;math/tex&quot;&gt;S_i \in \mathbb{R}^{\vert V \vert}&lt;/script&gt;, содержащем информацию о близости ноды ко всем другим нодам в графе. Затем данный вектор сжимается до нужной размерности. Проблема такого подхода в том, что он невероятно дорогой. К тому же метод статичный и плохо работает с изменяющимися графами.&lt;/p&gt;

&lt;p&gt;Другой подход — &lt;strong&gt;neighbourhood agregation&lt;/strong&gt; атрибутов нод для генерации эмбеддингов. Этот метод позволяет агрегировать «месседжи» от соседей ноды, которые, в свою очередь, базируются на «месседжах», агрегированных по соседям соседей и т.д. Иногда такие модели называют сверточными энкодерами из-за схожести их архитектуры со свертками.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../assets/img/191020-01.png&quot; alt=&quot;neighbourhood agregation&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Алгоритм такой сети выглядит так (взято из статьи Representation Learning on Graphs: Methods and Applicationsб Hamilton, William L.; Ying, Rex; Leskovec, Jure);&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../assets/img/191020-02.png&quot; alt=&quot;neighbourhood agregation algorythm&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Алгоритм строит эмбеддинги для нод рекурсивно&lt;/li&gt;
  &lt;li&gt;Вначале энкодер инициализируется атрибутами нод&lt;/li&gt;
  &lt;li&gt;Затем на каждой итерации агрегируются эмбеддинги соседей&lt;/li&gt;
  &lt;li&gt;Далее каждая нода получает новый эмбеддинг, скомбинированный из ее собственного эмбеддинга и агрегированного вектора.&lt;/li&gt;
  &lt;li&gt;Затем все это отправляется в полносвязный слой и процесс повторяется K раз.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Эмбеддинг каждой ноды обогащается данными своих соседей, при этом размерность векторов остается постоянной во время всей процедуры. В результате мы получаем векторное представление графа.&lt;/p&gt;

&lt;p&gt;Этот подход эксплуатируют:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;GNN (graph neural network)&lt;/li&gt;
  &lt;li&gt;GCN (graph convolutional networks)&lt;/li&gt;
  &lt;li&gt;column networks&lt;/li&gt;
  &lt;li&gt;GraphSAGE&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Разные подтипы модели определяются разными агрегирующей функцией и комбинирующей вектора функцией.&lt;/p&gt;

&lt;h4 id=&quot;gcn&quot;&gt;GCN&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;агрегирующая функция - поэлементное среднее&lt;/li&gt;
  &lt;li&gt;комбинируем взвешенной суммой&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;column-network&quot;&gt;column network&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;то же самое, что и в GCN, только на выходе цикла стоит функция интерполяции, позволяющая сохранять локальную информацию в процессе итерации)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;graphsage&quot;&gt;GraphSAGE&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;агрегирует среднее, макспуллинг или LSTM&lt;/li&gt;
  &lt;li&gt;комбинируем конкатенацией&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;gnn&quot;&gt;GNN&lt;/h4&gt;

&lt;p&gt;GNN — обобщающая вышеизложенные принципы модель. По сути, GNN описывает множество возможных реализаций, одна из которых — GCN, где в качестве основного механизма используется свертка.&lt;/p&gt;

&lt;p&gt;В базовой реализации, алгоритм инициализируется случайным эмбеддингом для каждой ноды и на каждой итерации эмбеддинги накапливают информацию о своих соседях вот таким образом:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../assets/img/191020-04.png&quot; alt=&quot;GNN embeddings&quot; /&gt;&lt;/p&gt;

&lt;p&gt;где &lt;script type=&quot;math/tex&quot;&gt;h&lt;/script&gt; — это произвольная дифференцируемая функция вида &lt;script type=&quot;math/tex&quot;&gt;р: \mathbb{R}^d \times \mathbb{R}^m \times \mathbb{R}^m \rightarrow \mathbb{R}^d&lt;/script&gt;. На выходе после &lt;script type=&quot;math/tex&quot;&gt;K&lt;/script&gt; итераций мы должны получить вектор вида &lt;script type=&quot;math/tex&quot;&gt;\mathbf{z}_{v_i} = g({\mathbf{h}_i}^K)&lt;/script&gt;, где &lt;script type=&quot;math/tex&quot;&gt;g&lt;/script&gt; - произвольная дифференцируемая функция вида &lt;script type=&quot;math/tex&quot;&gt;g: \mathbb{R}^d \rightarrow \mathbb{R}^d&lt;/script&gt;, иными словами, это некая нейросеть, возможно MLP.&lt;/p&gt;

&lt;p&gt;Практическую часть к данной статье смотрите &lt;a href=&quot;/2020/11/05/svertochnie-neyronnie-seti-dlja-grafov-chast-2-practica.html&quot;&gt;тут&lt;/a&gt;.&lt;/p&gt;</content><author><name>Klepikov Konstantin</name></author><category term="neural-network" /><category term="graphs" /><category term="convolutional" /><category term="cs224w" /><category term="GCN" /><category term="embedding" /><summary type="html"></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://konstantinklepikov.github.io/assets/img/191020banner.png" /><media:content medium="image" url="https://konstantinklepikov.github.io/assets/img/191020banner.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Алгоритмы поиска в ширину и в глубину</title><link href="https://konstantinklepikov.github.io/2020/10/09/breadth-first-and-depth-first-search-algorithms.html" rel="alternate" type="text/html" title="Алгоритмы поиска в ширину и в глубину" /><published>2020-10-09T00:00:00+02:00</published><updated>2020-10-09T00:00:00+02:00</updated><id>https://konstantinklepikov.github.io/2020/10/09/breadth-first-and-depth-first-search-algorithms</id><content type="html" xml:base="https://konstantinklepikov.github.io/2020/10/09/breadth-first-and-depth-first-search-algorithms.html">&lt;p&gt;&lt;img src=&quot;../../../assets/img/101020banner.png&quot; alt=&quot;Алгоритмы поиска в ширину и в глубину&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Поиск в ширину и поиск в глубину представляют две основных парадигмы обхода графов.&lt;/p&gt;

&lt;h2 id=&quot;поиск-в-ширину-breadth-first-search-bfs&quot;&gt;Поиск в ширину (breadth-first search, BFS)&lt;/h2&gt;

&lt;p&gt;Алгоритм поиска в ширину заключается в том, чтобы разведать вершины графа послойно, в порядке увеличения расстояния от стартовой ноды.&lt;/p&gt;

&lt;p&gt;Рассмотрим на примере и возьмем для этого простой связный ненаправленный граф, ребра которого не имеют весов или временных меток. Слой 0 содержит стартовую вершину. Слой 1 будет содержать множество вершин, которые находятся на расстояние одного ребра от стартовой. Каждый последующий слой будет удаляться от стартовой вершины ровно на одно ребро. Алгоритм разведает сначала все ближайшие к стартовой ноды, затем более удаленные и т.д. и завершит работу, когда будут разведаны все вершины и алгоритм не сможет пройти дальше. В нашем примере он остановится на слое 3.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../assets/img/101020-01.png&quot; alt=&quot;BFS&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Алгоритм реализуется на основе очереди FIFO (First In, First Out – «Первым пришёл — первым ушёл»), с помощью которого отслеживаются ноды, которые алгоритм уже посещал. Очередь позволяет добавлять объекты в конец списка и удалять объекты из начала за постоянное время.&lt;/p&gt;

&lt;h3 id=&quot;bfs-алгоритм&quot;&gt;BFS алгоритм&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Вход&lt;/strong&gt;: граф &lt;script type=&quot;math/tex&quot;&gt;G = (V, E)&lt;/script&gt;, где &lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt; это множество нод, а &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; множество ребер. Стартовая вершина &lt;script type=&quot;math/tex&quot;&gt;s \in V&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Выход&lt;/strong&gt; граф &lt;script type=&quot;math/tex&quot;&gt;G_{explored} = (V, E)&lt;/script&gt;, при условии, что каждая вершина такого графа достижима из s тогда и только тогда, когда она размечена алгоритмом как «разведанная».&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;пометить s как разведанную вершину, все остальные как неразведанные&lt;/li&gt;
  &lt;li&gt;определить очередь &lt;script type=&quot;math/tex&quot;&gt;Q&lt;/script&gt;, инициализированную вершиной s&lt;/li&gt;
  &lt;li&gt;до тех пор, пока очередь &lt;script type=&quot;math/tex&quot;&gt;Q&lt;/script&gt; непустая:&lt;/li&gt;
  &lt;li&gt;  удалить вершину из начала очереди &lt;script type=&quot;math/tex&quot;&gt;Q&lt;/script&gt;, обозначив ее как v&lt;/li&gt;
  &lt;li&gt;  для каждого ребра &lt;script type=&quot;math/tex&quot;&gt;(v, w)&lt;/script&gt; в списке смежности v:&lt;/li&gt;
  &lt;li&gt;    если w не разведана:&lt;/li&gt;
  &lt;li&gt;      пометить w как разведанную&lt;/li&gt;
  &lt;li&gt;      добавить w в конец &lt;script type=&quot;math/tex&quot;&gt;Q&lt;/script&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;BFS используется для поиска кратчайшего пути и связных компонент в графе.&lt;/p&gt;

&lt;h2 id=&quot;поиск-в-глубину-depth-first-search-dfs&quot;&gt;Поиск в глубину (depth-first search, DFS)&lt;/h2&gt;

&lt;p&gt;Алгоритм поиска в глубину отличается от поиска в ширину более агрессивным продвижением по графу. Он всегда сразу продвигается к самой отдаленной от стартовой ноды вершине и затем, если не может продвинуться дальше, отступает назад.&lt;/p&gt;

&lt;p&gt;Как и BFS, DFS помечает ноду каждый раз, как ее обнаруживает. На каждой итерации алгоритм обходит в произвольном порядке ноды, ближайшие к текущей. На первой же найденной вершине алгоритм будет пытаться найти ближайшие ноды к уже разведанной (в этом он отличается от BFS, который исследует ноды, ближайшие к стартовой) и будет делать это на каждой последующей итерации до тех пор, пока не окажется в ноде, из которой ему некуда уйти. Тогда алгоритм отступает назад и пытается продвинуться дальше по другому пути. Алгоритм так же останавливается, когда все доступные ноды будут разведаны.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../assets/img/101020-02.png&quot; alt=&quot;DFS&quot; /&gt;
&lt;img src=&quot;../../../assets/img/101020-03.png&quot; alt=&quot;DFS&quot; /&gt;
&lt;img src=&quot;../../../assets/img/101020-04.png&quot; alt=&quot;DFS&quot; /&gt;
&lt;img src=&quot;../../../assets/img/101020-05.png&quot; alt=&quot;DFS&quot; /&gt;&lt;/p&gt;

&lt;p&gt;DFS реализуется на основе стека LIFO (last in, first out, «последним пришёл — первым ушёл»).&lt;/p&gt;

&lt;h3 id=&quot;dfs-алгоритм&quot;&gt;DFS алгоритм&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Вход&lt;/strong&gt;: граф &lt;script type=&quot;math/tex&quot;&gt;G = (V, E)&lt;/script&gt;, где &lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt; это множество нод, а &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; множество ребер. Стартовая вершина &lt;script type=&quot;math/tex&quot;&gt;s \in V&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Выход&lt;/strong&gt; граф &lt;script type=&quot;math/tex&quot;&gt;G_{explored} = (V, E)&lt;/script&gt;, при условии, что каждая вершина такого графа достижима из s тогда и только тогда, когда она размечена алгоритмом как «разведанная».&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;пометить s как разведанную вершину, все остальные как неразведанные&lt;/li&gt;
  &lt;li&gt;определить стек &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt;, инициализированную вершиной s&lt;/li&gt;
  &lt;li&gt;до тех пор, пока стек &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt; непустой:&lt;/li&gt;
  &lt;li&gt;  удалить вершину сверху стека &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt;, обозначив ее как v&lt;/li&gt;
  &lt;li&gt;  если v не разведана:&lt;/li&gt;
  &lt;li&gt;    пометить v как разведанную&lt;/li&gt;
  &lt;li&gt;    для каждого ребра &lt;script type=&quot;math/tex&quot;&gt;(v, w)&lt;/script&gt; в списке смежности v:&lt;/li&gt;
  &lt;li&gt;      добавить w наверх стека &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Кроме того, алгоритм может быть реализован рекурсивно.&lt;/p&gt;

&lt;p&gt;DFS используется для топологической сортировки и определения сильно связанных компонент графа.&lt;/p&gt;

&lt;h2 id=&quot;свойства-алгоритмаов-dfs-и-dfs&quot;&gt;Свойства алгоритмаов DFS и DFS&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;вершина размечается как разведанная тогда и только тогда, когда существует путь из s в v в графе &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;время работы алгоритма &lt;script type=&quot;math/tex&quot;&gt;O(m + n)&lt;/script&gt;, где &lt;script type=&quot;math/tex&quot;&gt;m = \vert E \vert&lt;/script&gt;, а &lt;script type=&quot;math/tex&quot;&gt;n = \vert V \vert&lt;/script&gt; (для представления графа в виде списков смежности. Для матрицы смежности сложность составит &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt;)&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Klepikov Konstantin</name></author><category term="algorithms" /><category term="bfs" /><category term="dfs" /><category term="graphs" /><summary type="html"></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://konstantinklepikov.github.io/assets/img/101020banner.png" /><media:content medium="image" url="https://konstantinklepikov.github.io/assets/img/101020banner.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Обозначения в анализе алгоритмов</title><link href="https://konstantinklepikov.github.io/2020/09/30/oboznachenija-v-analize-algoritmov.html" rel="alternate" type="text/html" title="Обозначения в анализе алгоритмов" /><published>2020-09-30T00:00:00+02:00</published><updated>2020-09-30T00:00:00+02:00</updated><id>https://konstantinklepikov.github.io/2020/09/30/oboznachenija-v-analize-algoritmov</id><content type="html" xml:base="https://konstantinklepikov.github.io/2020/09/30/oboznachenija-v-analize-algoritmov.html">&lt;p&gt;&lt;img src=&quot;../../../assets/img/011020-01.png&quot; alt=&quot;Обозначения в анализе алгоритмов&quot; /&gt;&lt;/p&gt;

&lt;p&gt;В асимптотическом анализе алгоритмов принято использовать базовые обозначения, позволяющие формализовать сложность алгоритма. Все термины сводятся к устранению постоянных коэффициентов, так как они слишком зависимы от аппаратной и программной реализации, а так же к игнорированию членов низших порядков, так как с ростом объема данных такие вычисления перестают играть значимую роль.&lt;/p&gt;

&lt;h2 id=&quot;o-большое&quot;&gt;O-большое&lt;/h2&gt;

&lt;p&gt;Для функции, зависящей от длины &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; входных данных утверждается:&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;T(n) = O(f(n))&lt;/script&gt; тогда и только тогда, когда существуют положительные константы &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; и &lt;script type=&quot;math/tex&quot;&gt;n_{0}&lt;/script&gt;, такие что справедливо неравенство &lt;script type=&quot;math/tex&quot;&gt;T(n) \leq c \times f(n)&lt;/script&gt; для всех &lt;script type=&quot;math/tex&quot;&gt;n \geq n_{0}&lt;/script&gt;. Иными словами, &lt;script type=&quot;math/tex&quot;&gt;T(n)&lt;/script&gt; ограничена сверху функцией, кратной функции &lt;script type=&quot;math/tex&quot;&gt;f(n)&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../assets/img/011020-02.png&quot; alt=&quot;O большое&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Важно: &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; и &lt;script type=&quot;math/tex&quot;&gt;n_{0}&lt;/script&gt; не зависят от &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;&lt;/p&gt;

&lt;h2 id=&quot;omega-большое&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;\Omega&lt;/script&gt;-большое&lt;/h2&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\Omega&lt;/script&gt; имеет тот же смысл, что и &lt;script type=&quot;math/tex&quot;&gt;O&lt;/script&gt;, только функция, кратная &lt;script type=&quot;math/tex&quot;&gt;f(n)&lt;/script&gt; ограничивает &lt;script type=&quot;math/tex&quot;&gt;T(n)&lt;/script&gt; снизу. Таким образом, две нотации реализуют наихудший и наилучший случаи. &lt;script type=&quot;math/tex&quot;&gt;T(n) = \Omega(f(n))&lt;/script&gt; тогда и только тогда, когда существуют положительные константы &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; и &lt;script type=&quot;math/tex&quot;&gt;n_{0}&lt;/script&gt;, такие что справедливо неравенство &lt;script type=&quot;math/tex&quot;&gt;T(n) \geq c \times f(n)&lt;/script&gt; для всех &lt;script type=&quot;math/tex&quot;&gt;n \geq n_{0}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../assets/img/011020-03.png&quot; alt=&quot;Омега большое&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;theta-большое&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;\Theta&lt;/script&gt;-большое&lt;/h2&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;T(n) = \Theta(f(n))&lt;/script&gt; тогда и только тогда, когда существуют положительные константы &lt;script type=&quot;math/tex&quot;&gt;c_{1}&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;c_{2}&lt;/script&gt; и &lt;script type=&quot;math/tex&quot;&gt;n_{0}&lt;/script&gt;, такие что справедливо неравенство &lt;script type=&quot;math/tex&quot;&gt;c_{1} \times f(n) \leq T(n) \geq c_{2} \times f(n)&lt;/script&gt; для всех &lt;script type=&quot;math/tex&quot;&gt;n \geq n_{0}&lt;/script&gt;&lt;/p&gt;

&lt;h2 id=&quot;o-omega-theta-малые&quot;&gt;o, &lt;script type=&quot;math/tex&quot;&gt;\omega&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;\theta&lt;/script&gt;-малые&lt;/h2&gt;

&lt;p&gt;Малые нотации соответствуют большим, но при условии строго неравенества.&lt;/p&gt;

&lt;p&gt;Также читайте про &lt;a href=&quot;/2019/09/08/time-complexity-of-machine-learning-algorithms.html&quot;&gt;временную сложность в машинном обуче6нии&lt;/a&gt; и про &lt;a href=&quot;/2019/10/19/complexity-basics-terms.html&quot;&gt;базовые принципы временной сложности&lt;/a&gt;&lt;/p&gt;</content><author><name>Klepikov Konstantin</name></author><category term="algorithms" /><category term="time-complexity" /><summary type="html"></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://konstantinklepikov.github.io/assets/img/011020-01.png" /><media:content medium="image" url="https://konstantinklepikov.github.io/assets/img/011020-01.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Обработка пропусков в Pandas</title><link href="https://konstantinklepikov.github.io/2020/07/25/empty-data-processing-in-pandas.html" rel="alternate" type="text/html" title="Обработка пропусков в Pandas" /><published>2020-07-25T00:00:00+02:00</published><updated>2020-07-25T00:00:00+02:00</updated><id>https://konstantinklepikov.github.io/2020/07/25/empty-data-processing-in-pandas</id><content type="html" xml:base="https://konstantinklepikov.github.io/2020/07/25/empty-data-processing-in-pandas.html">&lt;p&gt;&lt;img src=&quot;../../../assets/img/250720banner.png&quot; alt=&quot;Обработка пропусков в Pandas&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;есть-несколько-стратегий-индикации-пропусков-в-данных&quot;&gt;Есть несколько стратегий индикации пропусков в данных&lt;/h3&gt;

&lt;h4 id=&quot;использование-некоего-значения-индикатора&quot;&gt;Использование некоего значения-индикатора&lt;/h4&gt;

&lt;p&gt;К примеру, можно использовать число -9999 или редко встречающееся сочетание битов. Более часто встречающийся способ — условное обозначение через NaN. NaN — это специальное значение, определенное спецификацией IEEE для чисел с плавающей точкой и используется во многих ЯП.&lt;/p&gt;

&lt;p&gt;У метода есть ограничения. Во-первых использование значений индикаторов может привести к дополнительным не оптимизированным расчетам. Во-вторых NaN доступен не для всех типов данных.&lt;/p&gt;

&lt;h4 id=&quot;использование-масок&quot;&gt;Использование масок&lt;/h4&gt;

&lt;p&gt;Можно создать отдельный булевый массив, индицирующий пропущенные значения. В ряде языков выделяется отдельный бит для разметки пропусков в массиве данных локально. Оба подхода влекут за собой перерасход памяти.&lt;/p&gt;

&lt;h4 id=&quot;как-это-реализовано-в-pandas&quot;&gt;Как это реализовано в Pandas?&lt;/h4&gt;

&lt;p&gt;Pandas построена на NumPy, в котором отсутствует понятие пропуска для всех данных кроме данных с плавающей точкой. NumPy поддерживает маски, но использование такого подходжа в Pandas влечет значительные накладные расходы на хранение, вычисление и поддержку кода.&lt;/p&gt;

&lt;p&gt;В итоге в Pandas используется:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;индикаторы-числа&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;NaN из Numpy&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;None из Python&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;объект-none&quot;&gt;Объект None&lt;/h3&gt;

&lt;p&gt;None - объект python. Его нельзя использовать в NumPy и во всех производных массивах Pandas. None используется только в массивах с типом object. Когда мы создаем массив, используя None, автоматически создается массив с типом object.&lt;/p&gt;

&lt;p&gt;Тип object означает, что NumPy не смог установить тип объектов массива, единственное что он знает — это то, что это объекты python. Операции с такими массивами будут производится на уровне языка python, т.е. со всеми накладными расходами, присущими языку с динамической типизацией. Оптимизация NumPy работать не будет.&lt;/p&gt;

&lt;p&gt;Кроме того, функции агрегирования по массиву, например, massive.sum() или massive.min() выбросят ошибку, так как операции между численным значением и значением None не определены&lt;/p&gt;

&lt;h3 id=&quot;объект-nan&quot;&gt;Объект NaN&lt;/h3&gt;

&lt;p&gt;Объект NaN определяет отсутствие числового значения с плавающей точкой. Это вызывает некоторые проблемы — если NaN попадает в массив, все данные приводятся к числам с плавающей точкой. Кроме того, все операции с NaN приводят к NaN, в том числе и функции агрегирования.&lt;/p&gt;

&lt;p&gt;Не забудьте, что для вызова объекта NaN нужен NumPy&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nan&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nan&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;nan-и-none&quot;&gt;Nan и None&lt;/h3&gt;

&lt;p&gt;Pandas преобразует None в NaN, если оба будут встречены в одном массиве. Естественно, осуществляется и повышающее преобразование с приведением всех непустых числовых значений к числу с плавающей точкой, а всех остальных к NaN.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;pd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Series&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;    &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;NaN&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;    &lt;span class=&quot;mf&quot;&gt;3.0&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;NaN&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dtype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;float64&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Series&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dtype&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'int8'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;    &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;    &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;    &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dtype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int8&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;NaN&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;    &lt;span class=&quot;mf&quot;&gt;2.0&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;    &lt;span class=&quot;mf&quot;&gt;3.0&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dtype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;float64&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Правила повышающих преобразований типов в Pandas (строки всегда хранятся как object)&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Typeclass&lt;/th&gt;
      &lt;th&gt;Conversion When Storing NAN&lt;/th&gt;
      &lt;th&gt;NAN Sentinel Value&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;floating&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;No change&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;np.nan&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;object&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;No change&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;None&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;np.nan&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;integer&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Cast to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;float64&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;np.nan&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;boolean&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Cast to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;object&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;None&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;np.nan&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;операции-над-пустыми-значениями&quot;&gt;Операции над пустыми значениями&lt;/h3&gt;

&lt;p&gt;В  Pandas доступно несколько методов:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;isnull() — генерирует булеву маску для отсутствующих значений&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;notnull() — тоже для непустых&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;dropna() — фильтрация данных по отсутствующим значениям&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;fillna() — замена пропусков с возвратом копии&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Методы доступны как для объектов Series так и для dataFrame (с выбором измерения).&lt;/p&gt;

&lt;p&gt;Кроме того, для dropna() ожно задать дополнительные параметры. how=’any’ задан по дефолту, можно переопределить как ‘all’ — будут отбрасываться только полностью пустые строки/столбцы. thresh задает минимальное значение непустых значений, выше которого строки/столбцы не отбрасываются.&lt;/p&gt;

&lt;p&gt;Для fillna() доступно несколько аргументов. method=’ffill’ и method=’bfill’ определяют какими значениями будут заполняться пропуски (предыдущими или последующими в массиве).&lt;/p&gt;

&lt;p&gt;Подробнее &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.fillna.html&quot;&gt;fillna()&lt;/a&gt; и &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.dropna.html&quot;&gt;dropna()&lt;/a&gt;&lt;/p&gt;</content><author><name>Klepikov Konstantin</name></author><category term="pandas" /><category term="preprocessing" /><category term="phyton" /><category term="machine-learning" /><category term="ml-data" /><summary type="html"></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://konstantinklepikov.github.io/assets/img/250720banner.png" /><media:content medium="image" url="https://konstantinklepikov.github.io/assets/img/250720banner.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>